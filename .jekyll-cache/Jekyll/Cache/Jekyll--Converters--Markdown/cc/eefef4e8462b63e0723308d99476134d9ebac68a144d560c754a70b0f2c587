I"ג<h1 id="sinatra">Sinatra</h1>

<p><em>注：本文档是英文版的翻译，内容更新有可能不及时。如有不一致的地方，请以英文版为准。</em></p>

<p>Sinatra 是一门基于
Ruby 的<a href="https://en.wikipedia.org/wiki/Domain-specific_language">领域专属语言</a>，致力于轻松、快速地创建网络应用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># myapp.rb</span>
<span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="s1">'Hello world!'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>安装 Sinatra 这个 gem：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem <span class="nb">install </span>sinatra
</code></pre></div></div>

<p>然后运行 myapp.rb 中的代码：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby myapp.rb
</code></pre></div></div>

<p>在该地址查看： <a href="http://localhost:4567">http://localhost:4567</a></p>

<p>推荐运行 <code class="highlighter-rouge">gem install thin</code> 安装 Thin。这样，Sinatra 会优先选择 Thin 作为服务器。</p>

<h2 id="目录">目录</h2>

<ul>
  <li><a href="#sinatra">Sinatra</a>
    <ul>
      <li><a href="#目录">目录</a></li>
      <li><a href="#路由">路由</a></li>
      <li><a href="#条件">条件</a></li>
      <li><a href="#返回值">返回值</a></li>
      <li><a href="#自定义路由匹配器">自定义路由匹配器</a></li>
      <li><a href="#静态文件">静态文件</a></li>
      <li><a href="#视图--模板">视图 / 模板</a>
        <ul>
          <li><a href="#字面量模板">字面量模板</a></li>
          <li><a href="#可选的模板语言">可选的模板语言</a>
            <ul>
              <li><a href="#haml-模板">Haml 模板</a></li>
              <li><a href="#erb-模板">Erb 模板</a></li>
              <li><a href="#builder-模板">Builder 模板</a></li>
              <li><a href="#nokogiri-模板">Nokogiri 模板</a></li>
              <li><a href="#sass-模板">Sass 模板</a></li>
              <li><a href="#scss-模板">SCSS 模板</a></li>
              <li><a href="#less-模板">Less 模板</a></li>
              <li><a href="#liquid-模板">Liquid 模板</a></li>
              <li><a href="#markdown-模板">Markdown 模板</a></li>
              <li><a href="#textile-模板">Textile 模板</a></li>
              <li><a href="#rdoc-模板">RDoc 模板</a></li>
              <li><a href="#asciidoc-模板">AsciiDoc 模板</a></li>
              <li><a href="#radius-模板">Radius 模板</a></li>
              <li><a href="#markaby-模板">Markaby 模板</a></li>
              <li><a href="#rabl-模板">RABL 模板</a></li>
              <li><a href="#slim-模板">Slim 模板</a></li>
              <li><a href="#creole-模板">Creole 模板</a></li>
              <li><a href="#mediawiki-模板">MediaWiki 模板</a></li>
              <li><a href="#coffeescript-模板">CoffeeScript 模板</a></li>
              <li><a href="#stylus-模板">Stylus 模板</a></li>
              <li><a href="#yajl-模板">Yajl 模板</a></li>
              <li><a href="#wlang-模板">WLang 模板</a></li>
            </ul>
          </li>
          <li><a href="#在模板中访问变量">在模板中访问变量</a></li>
          <li><a href="#带-yield-的模板和嵌套布局">带 <code class="highlighter-rouge">yield</code> 的模板和嵌套布局</a></li>
          <li><a href="#内联模板">内联模板</a></li>
          <li><a href="#具名模板">具名模板</a></li>
          <li><a href="#关联文件扩展名">关联文件扩展名</a></li>
          <li><a href="#添加自定义模板引擎">添加自定义模板引擎</a></li>
          <li><a href="#自定义模板查找逻辑">自定义模板查找逻辑</a></li>
        </ul>
      </li>
      <li><a href="#过滤器">过滤器</a></li>
      <li><a href="#辅助方法">辅助方法</a>
        <ul>
          <li><a href="#使用会话">使用会话</a></li>
          <li><a href="#中断请求">中断请求</a></li>
          <li><a href="#传递请求">传递请求</a></li>
          <li><a href="#触发另一个路由">触发另一个路由</a></li>
          <li><a href="#设置响应主体状态码和响应首部">设置响应主体、状态码和响应首部</a></li>
          <li><a href="#响应的流式传输">响应的流式传输</a></li>
          <li><a href="#日志">日志</a></li>
          <li><a href="#媒体类型">媒体类型</a></li>
          <li><a href="#生成-url">生成 URL</a></li>
          <li><a href="#浏览器重定向">浏览器重定向</a></li>
          <li><a href="#缓存控制">缓存控制</a></li>
          <li><a href="#发送文件">发送文件</a></li>
          <li><a href="#访问请求对象">访问请求对象</a></li>
          <li><a href="#附件">附件</a></li>
          <li><a href="#处理日期和时间">处理日期和时间</a></li>
          <li><a href="#查找模板文件">查找模板文件</a></li>
        </ul>
      </li>
      <li><a href="#配置">配置</a>
        <ul>
          <li><a href="#配置攻击防护">配置攻击防护</a></li>
          <li><a href="#可选的设置">可选的设置</a></li>
        </ul>
      </li>
      <li><a href="#环境">环境</a></li>
      <li><a href="#错误处理">错误处理</a>
        <ul>
          <li><a href="#未找到">未找到</a></li>
          <li><a href="#错误">错误</a></li>
        </ul>
      </li>
      <li><a href="#rack-中间件">Rack 中间件</a></li>
      <li><a href="#测试">测试</a></li>
      <li><a href="#sinatrabase---中间件库和模块化应用">Sinatra::Base - 中间件、库和模块化应用</a>
        <ul>
          <li><a href="#模块化风格-vs-经典风格">模块化风格 vs. 经典风格</a></li>
          <li><a href="#运行一个模块化应用">运行一个模块化应用</a></li>
          <li><a href="#使用-configru-运行经典风格的应用">使用 config.ru 运行经典风格的应用</a></li>
          <li><a href="#何时使用-configru">何时使用 config.ru？</a></li>
          <li><a href="#把-sinatra-当作中间件使用">把 Sinatra 当作中间件使用</a></li>
          <li><a href="#创建动态应用">创建动态应用</a></li>
        </ul>
      </li>
      <li><a href="#作用域和绑定">作用域和绑定</a>
        <ul>
          <li><a href="#应用类作用域">应用/类作用域</a></li>
          <li><a href="#请求实例作用域">请求/实例作用域</a></li>
          <li><a href="#代理作用域">代理作用域</a></li>
        </ul>
      </li>
      <li><a href="#命令行">命令行</a>
        <ul>
          <li><a href="#多线程">多线程</a></li>
        </ul>
      </li>
      <li><a href="#必要条件">必要条件</a></li>
      <li><a href="#紧跟前沿">紧跟前沿</a>
        <ul>
          <li><a href="#通过-bundler-使用-sinatra">通过 Bundler 使用 Sinatra</a></li>
          <li><a href="#使用自己本地的-sinatra">使用自己本地的 Sinatra</a></li>
          <li><a href="#全局安装">全局安装</a></li>
        </ul>
      </li>
      <li><a href="#版本">版本</a></li>
      <li><a href="#更多资料">更多资料</a></li>
    </ul>
  </li>
</ul>

<h2 id="路由">路由</h2>

<p>在 Sinatra 中，一个路由分为两部分：HTTP 方法和 URL 匹配范式。每个路由都有一个要执行的代码块：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">..</span> <span class="err">显示内容</span> <span class="o">..</span>
<span class="k">end</span>

<span class="n">post</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">..</span> <span class="err">创建内容</span> <span class="o">..</span>
<span class="k">end</span>

<span class="n">put</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">..</span> <span class="err">替换内容</span> <span class="o">..</span>
<span class="k">end</span>

<span class="n">patch</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">..</span> <span class="err">修改内容</span> <span class="o">..</span>
<span class="k">end</span>

<span class="n">delete</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">..</span> <span class="err">删除内容</span> <span class="o">..</span>
<span class="k">end</span>

<span class="n">options</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">..</span> <span class="err">显示命令列表</span> <span class="o">..</span>
<span class="k">end</span>

<span class="n">link</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">..</span> <span class="err">建立某种联系</span> <span class="o">..</span>
<span class="k">end</span>

<span class="n">unlink</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">..</span> <span class="err">解除某种联系</span> <span class="o">..</span>
<span class="k">end</span>
</code></pre></div></div>

<p>路由按照它们定义时的顺序进行匹配。第一个与请求匹配的路由会被调用。</p>

<p>路由范式可以包括具名参数，具名参数可以通过 <code class="highlighter-rouge">params</code> hash 访问：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/hello/:name'</span> <span class="k">do</span>
  <span class="c1"># 匹配 "GET /hello/foo" 和 "GET /hello/bar"</span>
  <span class="c1"># params['name'] 的值是 'foo' 或者 'bar'</span>
  <span class="s2">"Hello </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>也可以通过代码块参数访问具名参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/hello/:name'</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
  <span class="c1"># 匹配 "GET /hello/foo" 和 "GET /hello/bar"</span>
  <span class="c1"># params['name'] 的值是 'foo' 或者 'bar'</span>
  <span class="c1"># n 存储 params['name'] 的值</span>
  <span class="s2">"Hello </span><span class="si">#{</span><span class="n">n</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>路由范式也可以包含通配符参数， 参数值可以通过 <code class="highlighter-rouge">params['splat']</code> 数组访问。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/say/*/to/*'</span> <span class="k">do</span>
  <span class="c1"># 匹配 "GET /say/hello/to/world"</span>
  <span class="n">params</span><span class="p">[</span><span class="s1">'splat'</span><span class="p">]</span> <span class="c1"># =&gt; ["hello", "world"]</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/download/*.*'</span> <span class="k">do</span>
  <span class="c1"># 匹配 "GET /download/path/to/file.xml"</span>
  <span class="n">params</span><span class="p">[</span><span class="s1">'splat'</span><span class="p">]</span> <span class="c1"># =&gt; ["path/to/file", "xml"]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>或者通过代码块参数访问：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/download/*.*'</span> <span class="k">do</span> <span class="o">|</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="o">|</span>
  <span class="p">[</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="p">]</span> <span class="c1"># =&gt; ["path/to/file", "xml"]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过正则表达式匹配路由：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="sr">/\/hello\/([\w]+)/</span> <span class="k">do</span>
  <span class="s2">"Hello, </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'captures'</span><span class="p">].</span><span class="nf">first</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>或者使用代码块参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="sr">%r{/hello/([</span><span class="se">\w</span><span class="sr">]+)}</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
  <span class="c1"># 匹配 "GET /meta/hello/world"、"GET /hello/world/1234" 等</span>
  <span class="s2">"Hello, </span><span class="si">#{</span><span class="n">c</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>路由范式可以包含可选参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/posts/:format?'</span> <span class="k">do</span>
  <span class="c1"># 匹配 "GET /posts/" 和任意扩展 "GET /posts/json"、"GET /posts/xml" 等</span>
<span class="k">end</span>
</code></pre></div></div>

<p>路由也可以使用查询参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/posts'</span> <span class="k">do</span>
  <span class="c1"># 匹配 "GET /posts?title=foo&amp;author=bar"</span>
  <span class="n">title</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'title'</span><span class="p">]</span>
  <span class="n">author</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'author'</span><span class="p">]</span>
  <span class="c1"># 使用 title 和 author 变量；对于 /posts 路由来说，查询字符串是可选的</span>
<span class="k">end</span>
</code></pre></div></div>
<p>顺便一提，除非你禁用了路径遍历攻击防护（见下文），请求路径可能在匹配路由前发生改变。</p>

<p>你也可以通过<code class="highlighter-rouge">:mustermann_opt</code>选项定义<a href="https://github.com/sinatra/mustermann">Mustermann</a>来匹配路由。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'\A/posts\z'</span><span class="p">,</span> <span class="ss">:mustermann_opts</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:regexp</span><span class="p">,</span> <span class="ss">:check_anchors</span> <span class="o">=&gt;</span> <span class="kp">false</span> <span class="p">}</span> <span class="k">do</span>
  <span class="c1"># matches /posts exactly, with explicit anchoring</span>
  <span class="s2">"If you match an anchored pattern clap your hands!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>它看起来像一个<a href="https://github.com/sinatra/sinatra/blob/master/README.zh.md#%E6%9D%A1%E4%BB%B6">条件</a>，但实际不是！这些选项将被合并到全局的<code class="highlighter-rouge">mustermann_opts</code>。</p>

<h3 id="条件">条件</h3>

<p>路由可以包含各种匹配条件，比如 user agent：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span><span class="p">,</span> <span class="ss">:agent</span> <span class="o">=&gt;</span> <span class="sr">/Songbird (\d\.\d)[\d\/]*?/</span> <span class="k">do</span>
  <span class="s2">"你正在使用 Songbird，版本是 </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'agent'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="c1"># 匹配非 Songbird 浏览器</span>
<span class="k">end</span>
</code></pre></div></div>

<p>其它可以使用的条件有 <code class="highlighter-rouge">host_name</code> 和 <code class="highlighter-rouge">provides</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span><span class="p">,</span> <span class="ss">:host_name</span> <span class="o">=&gt;</span> <span class="sr">/^admin\./</span> <span class="k">do</span>
  <span class="s2">"管理员区域，无权进入！"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span><span class="p">,</span> <span class="ss">:provides</span> <span class="o">=&gt;</span> <span class="s1">'html'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span><span class="p">,</span> <span class="ss">:provides</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'rss'</span><span class="p">,</span> <span class="s1">'atom'</span><span class="p">,</span> <span class="s1">'xml'</span><span class="p">]</span> <span class="k">do</span>
  <span class="n">builder</span> <span class="ss">:feed</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">provides</code> 会搜索请求的 Accept 首部字段。</p>

<p>也可以轻易地使用自定义条件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span><span class="p">(</span><span class="ss">:probability</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span> <span class="n">condition</span> <span class="p">{</span> <span class="nb">rand</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="p">}</span> <span class="p">}</span>

<span class="n">get</span> <span class="s1">'/win_a_car'</span><span class="p">,</span> <span class="ss">:probability</span> <span class="o">=&gt;</span> <span class="mf">0.1</span> <span class="k">do</span>
  <span class="s2">"You won!"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/win_a_car'</span> <span class="k">do</span>
  <span class="s2">"Sorry, you lost."</span>
<span class="k">end</span>
</code></pre></div></div>

<p>对于一个需要提供多个值的条件，可以使用 splat：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span><span class="p">(</span><span class="ss">:auth</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">roles</span><span class="o">|</span>   <span class="c1"># &lt;- 注意此处使用了 splat</span>
  <span class="n">condition</span> <span class="k">do</span>
    <span class="k">unless</span> <span class="n">logged_in?</span> <span class="o">&amp;&amp;</span> <span class="n">roles</span><span class="p">.</span><span class="nf">any?</span> <span class="p">{</span><span class="o">|</span><span class="n">role</span><span class="o">|</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">in_role?</span> <span class="n">role</span> <span class="p">}</span>
      <span class="n">redirect</span> <span class="s2">"/login/"</span><span class="p">,</span> <span class="mi">303</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s2">"/my/account/"</span><span class="p">,</span> <span class="ss">:auth</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:user</span><span class="p">,</span> <span class="ss">:admin</span><span class="p">]</span> <span class="k">do</span>
  <span class="s2">"Your Account Details"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s2">"/only/admin/"</span><span class="p">,</span> <span class="ss">:auth</span> <span class="o">=&gt;</span> <span class="ss">:admin</span> <span class="k">do</span>
  <span class="s2">"Only admins are allowed here!"</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="返回值">返回值</h3>

<p>路由代码块的返回值至少决定了返回给
HTTP 客户端的响应主体，或者至少决定了在
Rack 堆栈中的下一个中间件。大多数情况下，返回值是一个字符串，就像上面的例子中的一样。但是，其它类型的值也是可以接受的。</p>

<p>你可以返回任何对象，该对象要么是一个合理的 Rack 响应，要么是一个 Rack body 对象，要么是 HTTP 状态码：</p>

<ul>
  <li>一个包含三个元素的数组: <code class="highlighter-rouge">[状态 (Integer), 响应首部 (Hash), 响应主体 (可以响应 #each 方法)]</code></li>
  <li>一个包含两个元素的数组: <code class="highlighter-rouge">[状态 (Integer), 响应主体 (可以响应 #each 方法)]</code></li>
  <li>一个响应 <code class="highlighter-rouge">#each</code> 方法，只传回字符串的对象</li>
  <li>一个代表状态码的数字</li>
</ul>

<p>例如，我们可以轻松地实现流式传输：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Stream</span>
  <span class="k">def</span> <span class="nf">each</span>
    <span class="mi">100</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="k">yield</span> <span class="s2">"</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="no">Stream</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>
</code></pre></div></div>

<p>也可以使用 <code class="highlighter-rouge">stream</code> 辅助方法（见下文描述）以减少样板代码并在路由中直接使用流式传输。</p>

<h3 id="自定义路由匹配器">自定义路由匹配器</h3>

<p>如上文所示，Sinatra
本身支持使用字符串和正则表达式作为路由匹配。但不限于此，你可以轻松地定义自己的匹配器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AllButPattern</span>
  <span class="no">Match</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:captures</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">except</span><span class="p">)</span>
    <span class="vi">@except</span>   <span class="o">=</span> <span class="n">except</span>
    <span class="vi">@captures</span> <span class="o">=</span> <span class="no">Match</span><span class="p">.</span><span class="nf">new</span><span class="p">([])</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="vi">@captures</span> <span class="k">unless</span> <span class="vi">@except</span> <span class="o">===</span> <span class="n">str</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">all_but</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
  <span class="no">AllButPattern</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">get</span> <span class="n">all_but</span><span class="p">(</span><span class="s2">"/index"</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上面的例子可能太繁琐了， 因为它也可以用更简单的方式表述：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="sr">//</span> <span class="k">do</span>
  <span class="n">pass</span> <span class="k">if</span> <span class="n">request</span><span class="p">.</span><span class="nf">path_info</span> <span class="o">==</span> <span class="s2">"/index"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>或者，使用消极向前查找:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="sr">%r{(?!/index)}</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="静态文件">静态文件</h2>

<p>静态文件从 <code class="highlighter-rouge">./public</code> 目录提供服务。可以通过设置<code class="highlighter-rouge">:public_folder</code> 选项设定一个不同的位置：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:public_folder</span><span class="p">,</span> <span class="no">File</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span> <span class="o">+</span> <span class="s1">'/static'</span>
</code></pre></div></div>

<p>请注意 public 目录名并没有包含在 URL 中。文件 <code class="highlighter-rouge">./public/css/style.css</code> 可以通过
<code class="highlighter-rouge">http://example.com/css/style.css</code> 访问。</p>

<p>可以使用 <code class="highlighter-rouge">:static_cache_control</code> 设置（见下文）添加 <code class="highlighter-rouge">Cache-Control</code> 首部信息。</p>

<h2 id="视图--模板">视图 / 模板</h2>

<p>每一门模板语言都将自身的渲染方法暴露给
Sinatra 调用。这些渲染方法只是简单地返回字符串。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这段代码会渲染 <code class="highlighter-rouge">views/index.erb</code> 文件。</p>

<p>除了模板文件名，也可以直接传入模板内容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">code</span> <span class="o">=</span> <span class="s2">"&lt;%= Time.now %&gt;"</span>
  <span class="n">erb</span> <span class="n">code</span>
<span class="k">end</span>
</code></pre></div></div>

<p>渲染方法接受第二个参数，即选项 hash：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:index</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="ss">:post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这段代码会将 <code class="highlighter-rouge">views/index.erb</code> 嵌入在 <code class="highlighter-rouge">views/post.erb</code>
布局中并一起渲染（<code class="highlighter-rouge">views/layout.erb</code> 是默认的布局，如果它存在的话）。</p>

<p>任何 Sinatra 不能理解的选项都会传递给模板引擎。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span><span class="p">,</span> <span class="ss">:format</span> <span class="o">=&gt;</span> <span class="ss">:html5</span>
<span class="k">end</span>
</code></pre></div></div>

<p>也可以为每种模板语言设置通用的选项：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:haml</span><span class="p">,</span> <span class="ss">:format</span> <span class="o">=&gt;</span> <span class="ss">:html5</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在渲染方法中传入的选项会覆盖通过 <code class="highlighter-rouge">set</code> 设置的通用选项。</p>

<p>可用的选项：</p>

<dl>
  <dt>locals</dt>
  <dd>
    传递给模板文档的 locals 对象列表。对于 partials
    很方便。例如：<tt>erb "&lt;%= foo %&gt;", :locals =&gt; {:foo =&gt; "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>默认的字符编码。默认值为 <tt>settings.default_encoding</tt>。</dd>

  <dt>views</dt>
  <dd>存放模板文件的目录。默认为 <tt>settings.views</tt>。</dd>

  <dt>layout</dt>
  <dd>
    是否使用布局 (<tt>true</tt> 或 <tt>false</tt>)。
    如果使用一个符号类型的值，则是用于明确使用的模板。例如：
    <tt>erb :index, :layout =&gt; !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>由模板生成的 Content-Type。默认值由模板语言决定。</dd>

  <dt>scope</dt>
  <dd>
    渲染模板时的作用域。默认值为应用类的实例对象。如果更改此项，实例变量和辅助方法将不可用。
  </dd>

  <dt>layout_engine</dt>
  <dd>
    渲染布局所使用的模板引擎。用于不支持布局的模板语言。默认值为模板所使用的引擎。例如：
    <tt>set :rdoc, :layout_engine =&gt; :erb</tt>
  </dd>

  <dt>layout_options</dt>
  <dd>
    渲染布局的特殊选项。例如：
    <tt>set :rdoc, :layout_options =&gt; { :views =&gt; 'views/layouts' }</tt>
  </dd>
</dl>

<p>Sinatra 假定模板文件直接位于 <code class="highlighter-rouge">./views</code> 目录。要使用不同的视图目录：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:views</span><span class="p">,</span> <span class="n">settings</span><span class="p">.</span><span class="nf">root</span> <span class="o">+</span> <span class="s1">'/templates'</span>
</code></pre></div></div>

<p>需要牢记的一点是，你必须通过符号引用模板， 即使它们存放在子目录下
（在这种情况下，使用 <code class="highlighter-rouge">:'subdir/template'</code> 或 <code class="highlighter-rouge">'subdir/template'.to_sym</code>）。
如果你不使用符号，渲染方法会直接渲染你传入的任何字符串。</p>

<h3 id="字面量模板">字面量模板</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="s1">'%div.title Hello World'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这段代码直接渲染模板字符串。</p>

<h3 id="可选的模板语言">可选的模板语言</h3>

<p>一些语言有多种实现。为了确定使用哪种实现（以及保证线程安全），你应该首先引入该实现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rdiscount'</span> <span class="c1"># 或 require 'bluecloth'</span>
<span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="n">markdown</span> <span class="ss">:index</span> <span class="p">}</span>
</code></pre></div></div>

<h4 id="haml-模板">Haml 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>haml :index, :format =&gt; :html5</tt></td>
  </tr>
</table>

<h4 id="erb-模板">Erb 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      或 erb (Ruby 标准库中已经包含)
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt> or <tt>.erubis</tt> (仅用于 Erubis)</td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

<h4 id="builder-模板">Builder 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      <a href="https://github.com/jimweirich/builder" title="builder">builder</a>
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>builder { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

<p><code class="highlighter-rouge">builder</code> 渲染方法也接受一个代码块，用于内联模板（见例子）。</p>

<h4 id="nokogiri-模板">Nokogiri 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://www.nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>nokogiri { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

<p><code class="highlighter-rouge">nokogiri</code> 渲染方法也接受一个代码块，用于内联模板（见例子）。</p>

<h4 id="sass-模板">Sass 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>sass :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>

<h4 id="scss-模板">SCSS 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>scss :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>

<h4 id="less-模板">Less 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://lesscss.org/" title="less">less</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>

<h4 id="liquid-模板">Liquid 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://shopify.github.io/liquid/" title="liquid">liquid</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>liquid :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>

<p>因为不能在 Liquid 模板中调用 Ruby 方法（除了 <code class="highlighter-rouge">yield</code>），你几乎总是需要传递 locals 对象给它。</p>

<h4 id="markdown-模板">Markdown 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      下列任一:
        <a href="https://github.com/davidfstr/rdiscount" title="RDiscount">RDiscount</a>,
        <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
        <a href="https://github.com/ged/bluecloth" title="bluecloth">BlueCloth</a>,
        <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a>,
        <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt> and <tt>.md</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>markdown :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>不能在 markdown 中调用 Ruby 方法，也不能传递 locals 给它。
因此，你一般会结合其它的渲染引擎来使用它：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">markdown</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>请注意你也可以在其它模板中调用 markdown 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">markdown</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre></div></div>

<p>因为不能在 Markdown 中使用 Ruby 语言，你不能使用 Markdown 书写的布局。
不过，使用其它渲染引擎作为模板的布局是可能的，这需要通过传入 <code class="highlighter-rouge">:layout_engine</code> 选项。</p>

<h4 id="textile-模板">Textile 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>textile :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>不能在 textile 中调用 Ruby 方法，也不能传递 locals 给它。
因此，你一般会结合其它的渲染引擎来使用它：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">textile</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>请注意你也可以在其他模板中调用 <code class="highlighter-rouge">textile</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">textile</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre></div></div>

<p>因为不能在 Textile 中调用 Ruby 方法，你不能用 Textile 书写布局。
不过，使用其它渲染引擎作为模版的布局是可能的，这需要通过传递 <code class="highlighter-rouge">:layout_engine</code> 选项。</p>

<h4 id="rdoc-模板">RDoc 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">RDoc</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>rdoc :README, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>不能在 rdoc 中调用 Ruby 方法，也不能传递 locals 给它。
因此，你一般会结合其它的渲染引擎来使用它：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">rdoc</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>请注意你也可以在其他模板中调用 <code class="highlighter-rouge">rdoc</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">rdoc</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre></div></div>

<p>因为不能在 RDoc 中调用 Ruby 方法，你不能用 RDoc 书写布局。
不过，使用其它渲染引擎作为模版的布局是可能的，这需要通过传递 <code class="highlighter-rouge">:layout_engine</code> 选项。</p>

<h4 id="asciidoc-模板">AsciiDoc 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://asciidoctor.org/" title="Asciidoctor">Asciidoctor</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.asciidoc</tt>, <tt>.adoc</tt> and <tt>.ad</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>asciidoc :README, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>因为不能在 AsciiDoc 模板中直接调用 Ruby 方法，你几乎总是需要传递 locals 对象给它。</p>

<h4 id="radius-模板">Radius 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">Radius</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>radius :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>

<p>因为不能在 Radius 模板中直接调用 Ruby 方法，你几乎总是可以传递 locals 对象给它。</p>

<h4 id="markaby-模板">Markaby 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://markaby.github.io/" title="Markaby">Markaby</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>markaby { h1 "Welcome!" }</tt></td>
  </tr>
</table>

<p><code class="highlighter-rouge">markaby</code> 渲染方法也接受一个代码块，用于内联模板（见例子）。</p>

<h4 id="rabl-模板">RABL 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

<h4 id="slim-模板">Slim 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

<h4 id="creole-模板">Creole 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>creole :wiki, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>不能在 creole 中调用 Ruby 方法，也不能传递 locals 对象给它。
因此你一般会结合其它的渲染引擎来使用它：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">creole</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>注意你也可以在其它模板内调用 <code class="highlighter-rouge">creole</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">creole</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre></div></div>

<p>因为不能在 Creole 模板文件内调用 Ruby 方法，你不能用 Creole 书写布局文件。
然而，使用其它渲染引擎作为模版的布局是可能的，这需要通过传递 <code class="highlighter-rouge">:layout_engine</code> 选项。</p>

<h4 id="mediawiki-模板">MediaWiki 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/nricciar/wikicloth" title="WikiCloth">WikiCloth</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.mediawiki</tt> and <tt>.mw</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>mediawiki :wiki, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>在 MediaWiki 标记文件内不能调用 Ruby 方法，也不能传递 locals 对象给它。
因此你一般会结合其它的渲染引擎来使用它：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">mediawiki</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>注意你也可以在其它模板内调用 <code class="highlighter-rouge">mediawiki</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">mediawiki</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre></div></div>

<p>因为不能在 MediaWiki 文件内调用 Ruby 方法，你不能用 MediaWiki 书写布局文件。
然而，使用其它渲染引擎作为模版的布局是可能的，这需要通过传递 <code class="highlighter-rouge">:layout_engine</code> 选项。</p>

<h4 id="coffeescript-模板">CoffeeScript 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> 以及一种
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        执行 JavaScript 的方式
      </a>
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

<h4 id="stylus-模板">Stylus 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td>
      <a href="https://github.com/forgecrafted/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> 以及一种
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        执行 JavaScript 的方式
      </a>
    </td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

<p>在使用 Stylus 模板之前，你需要先加载 <code class="highlighter-rouge">stylus</code> 和 <code class="highlighter-rouge">stylus/tilt</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>
<span class="nb">require</span> <span class="s1">'stylus'</span>
<span class="nb">require</span> <span class="s1">'stylus/tilt'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">stylus</span> <span class="ss">:example</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="yajl-模板">Yajl 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td>
      <tt>
        yajl :index,
             :locals =&gt; { :key =&gt; 'qux' },
             :callback =&gt; 'present',
             :variable =&gt; 'resource'
      </tt>
    </td>
  </tr>
</table>

<p>模板文件的源码作为一个 Ruby 字符串被求值，得到的 json 变量是通过 <code class="highlighter-rouge">#to_json</code> 方法转换的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">json</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:foo</span> <span class="o">=&gt;</span> <span class="s1">'bar'</span> <span class="p">}</span>
<span class="n">json</span><span class="p">[</span><span class="ss">:baz</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
</code></pre></div></div>

<p>可以使用 <code class="highlighter-rouge">:callback</code> 和 <code class="highlighter-rouge">:variable</code> 选项装饰被渲染的对象：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">resource</span> <span class="o">=</span> <span class="p">{</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">baz</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">qux</span><span class="dl">"</span><span class="p">};</span>
<span class="nx">present</span><span class="p">(</span><span class="nx">resource</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="wlang-模板">WLang 模板</h4>

<table>
  <tr>
    <td>依赖项</td>
    <td><a href="https://github.com/blambeau/wlang/" title="WLang">WLang</a></td>
  </tr>
  <tr>
    <td>文件扩展名</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>例子</td>
    <td><tt>wlang :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>

<p>因为在 WLang 中调用 Ruby 方法不符合语言习惯，你几乎总是需要传递 locals 给 WLang 木板。
然而，可以用 WLang 编写布局文件，也可以在 WLang 中使用 <code class="highlighter-rouge">yield</code> 方法。</p>

<h3 id="在模板中访问变量">在模板中访问变量</h3>

<p>模板的求值发生在路由处理器内部的上下文中。模板可以直接访问路由处理器中设置的实例变量。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/:id'</span> <span class="k">do</span>
  <span class="vi">@foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">'id'</span><span class="p">])</span>
  <span class="n">haml</span> <span class="s1">'%h1= @foo.name'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>或者，也可以显式地指定一个由局部变量组成的 locals 哈希：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/:id'</span> <span class="k">do</span>
  <span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">'id'</span><span class="p">])</span>
  <span class="n">haml</span> <span class="s1">'%h1= foo.name'</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:foo</span> <span class="o">=&gt;</span> <span class="n">foo</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>locals 哈希典型的使用情景是在别的模板中渲染 partials。</p>

<h3 id="带-yield-的模板和嵌套布局">带 <code class="highlighter-rouge">yield</code> 的模板和嵌套布局</h3>

<p>布局通常就是使用了 <code class="highlighter-rouge">yield</code> 方法的模板。
这样的布局文件可以通过上面描述的 <code class="highlighter-rouge">:template</code> 选项指定，也可以通过下面的代码块渲染：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">erb</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="kp">false</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这段代码几乎完全等同于 <code class="highlighter-rouge">erb :index, :layout =&gt; :post</code>。</p>

<p>向渲染方法传递代码块对于创建嵌套布局是最有用的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">erb</span> <span class="ss">:main_layout</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="kp">false</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:admin_layout</span> <span class="k">do</span>
    <span class="n">erb</span> <span class="ss">:user</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>代码行数可以更少：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">erb</span> <span class="ss">:admin_layout</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="ss">:main_layout</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:user</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当前，以下的渲染方法接受一个代码块：<code class="highlighter-rouge">erb</code>、<code class="highlighter-rouge">haml</code>、<code class="highlighter-rouge">liquid</code>、<code class="highlighter-rouge">slim </code> 和 <code class="highlighter-rouge">wlang</code>。
通用的 <code class="highlighter-rouge">render</code> 方法也接受。</p>

<h3 id="内联模板">内联模板</h3>

<p>模板可以在源文件的末尾定义：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span>
<span class="k">end</span>

<span class="cp">__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world.
</span></code></pre></div></div>

<p>注意：在引入了 sinatra 的源文件中定义的内联模板会自动载入。
如果你在其他源文件中也有内联模板，需要显式调用 <code class="highlighter-rouge">enable :inline_templates</code>。</p>

<h3 id="具名模板">具名模板</h3>

<p>可以使用顶层 <code class="highlighter-rouge">template</code> 方法定义模板：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">template</span> <span class="ss">:layout</span> <span class="k">do</span>
  <span class="s2">"%html</span><span class="se">\n</span><span class="s2">  =yield</span><span class="se">\n</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">template</span> <span class="ss">:index</span> <span class="k">do</span>
  <span class="s1">'%div.title Hello World!'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果存在名为 “layout” 的模板，该模板会在每个模板渲染的时候作为布局使用。
你可以为渲染方法传送 <code class="highlighter-rouge">:layout =&gt; false</code> 来禁用该次渲染的布局，
也可以设置 <code class="highlighter-rouge">set :haml, :layout =&gt; false</code> 来默认禁用布局。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="n">request</span><span class="p">.</span><span class="nf">xhr?</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="关联文件扩展名">关联文件扩展名</h3>

<p>为了将一个文件扩展名到对应的模版引擎，要使用 <code class="highlighter-rouge">Tilt.register</code>。
比如，如果你喜欢使用 <code class="highlighter-rouge">tt</code> 作为 Textile 模版的扩展名，你可以这样做:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Tilt</span><span class="p">.</span><span class="nf">register</span> <span class="ss">:tt</span><span class="p">,</span> <span class="no">Tilt</span><span class="p">[</span><span class="ss">:textile</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="添加自定义模板引擎">添加自定义模板引擎</h3>

<p>首先，通过 Tilt 注册你自定义的引擎，然后创建一个渲染方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Tilt</span><span class="p">.</span><span class="nf">register</span> <span class="ss">:myat</span><span class="p">,</span> <span class="no">MyAwesomeTemplateEngine</span>

<span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">myat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="n">render</span><span class="p">(</span><span class="ss">:myat</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">myat</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这段代码将会渲染 <code class="highlighter-rouge">./views/index.myat</code> 文件。
查看 https://github.com/rtomayko/tilt 以了解更多关于 Tilt 的信息。</p>

<h3 id="自定义模板查找逻辑">自定义模板查找逻辑</h3>

<p>要实现自定义的模板查找机制，你可以构建自己的 <code class="highlighter-rouge">#find_template</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">configure</span> <span class="k">do</span>
  <span class="n">set</span> <span class="ss">:views</span><span class="p">,</span> <span class="p">[</span> <span class="s1">'./views/a'</span><span class="p">,</span> <span class="s1">'./views/b'</span> <span class="p">]</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">find_template</span><span class="p">(</span><span class="n">views</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Array</span><span class="p">(</span><span class="n">views</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">v</span><span class="o">|</span>
    <span class="k">super</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="过滤器">过滤器</h2>

<p><code class="highlighter-rouge">before</code> 过滤器在每个请求之前调用，调用的上下文与请求的上下文相同，并且可以修改请求和响应。
在过滤器中设置的变量可以被路由和模板访问：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">before</span> <span class="k">do</span>
  <span class="vi">@note</span> <span class="o">=</span> <span class="s1">'Hi!'</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">path_info</span> <span class="o">=</span> <span class="s1">'/foo/bar/baz'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/foo/*'</span> <span class="k">do</span>
  <span class="vi">@note</span> <span class="c1">#=&gt; 'Hi!'</span>
  <span class="n">params</span><span class="p">[</span><span class="s1">'splat'</span><span class="p">]</span> <span class="c1">#=&gt; 'bar/baz'</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">after</code> 过滤器在每个请求之后调用，调用上下文与请求的上下文相同，并且也会修改请求和响应。
在 <code class="highlighter-rouge">before</code> 过滤器和路由中设置的实例变量可以被 <code class="highlighter-rouge">after</code> 过滤器访问：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">after</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="n">response</span><span class="p">.</span><span class="nf">status</span>
<span class="k">end</span>
</code></pre></div></div>

<p>请注意：除非你显式使用 <code class="highlighter-rouge">body</code> 方法，而不是在路由中直接返回字符串，
响应主体在 <code class="highlighter-rouge">after</code> 过滤器是不可访问的， 因为它在之后才会生成。</p>

<p>过滤器可以可选地带有范式， 只有请求路径满足该范式时才会执行：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">before</span> <span class="s1">'/protected/*'</span> <span class="k">do</span>
  <span class="n">authenticate!</span>
<span class="k">end</span>

<span class="n">after</span> <span class="s1">'/create/:slug'</span> <span class="k">do</span> <span class="o">|</span><span class="n">slug</span><span class="o">|</span>
  <span class="n">session</span><span class="p">[</span><span class="s1">'last_slug'</span><span class="p">]</span> <span class="o">=</span> <span class="n">slug</span>
<span class="k">end</span>
</code></pre></div></div>

<p>和路由一样，过滤器也可以带有条件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">before</span> <span class="ss">:agent</span> <span class="o">=&gt;</span> <span class="sr">/Songbird/</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="n">after</span> <span class="s1">'/blog/*'</span><span class="p">,</span> <span class="ss">:host_name</span> <span class="o">=&gt;</span> <span class="s1">'example.com'</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="辅助方法">辅助方法</h2>

<p>使用顶层的 <code class="highlighter-rouge">helpers</code> 方法来定义辅助方法， 以便在路由处理器和模板中使用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">bar"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/:name'</span> <span class="k">do</span>
  <span class="n">bar</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>也可以在多个分散的模块中定义辅助方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">FooUtils</span>
  <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">foo"</span> <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">BarUtils</span>
  <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">bar"</span> <span class="k">end</span>
<span class="k">end</span>

<span class="n">helpers</span> <span class="no">FooUtils</span><span class="p">,</span> <span class="no">BarUtils</span>
</code></pre></div></div>

<p>以上代码块与在应用类中包含模块等效。</p>

<h3 id="使用会话">使用会话</h3>

<p>会话用于在请求之间保持状态。如果激活了会话，每一个用户会话都对应一个会话 hash：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enable</span> <span class="ss">:sessions</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="s2">"value = "</span> <span class="o">&lt;&lt;</span> <span class="n">session</span><span class="p">[</span><span class="s1">'value'</span><span class="p">].</span><span class="nf">inspect</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/:value'</span> <span class="k">do</span>
  <span class="n">session</span><span class="p">[</span><span class="s1">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'value'</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="会话加密">会话加密</h4>

<p>为提高安全性，cookie 中的会话数据使用<code class="highlighter-rouge">HMAC-SHA1</code>进行加密。会话加密的最佳实践应当是像<code class="highlighter-rouge">HMAC-SHA1</code>这样生成大于或等于64字节 (512 bits, 128 hex characters)的随机值。应当避免使用少于32字节(256 bits, 64 hex characters)的随机值。应当使用生成器来创建安全的密钥，而不是拍脑袋决定。</p>

<p>默认情况下，Sinatra会生成一个32字节的密钥，但随着应用程序的每次重新启动，它都会发生改变。如果有多个应用程序的实例，使用Sinatra生成密钥，每个实例将有不同的密钥，这可能不是您想要的。</p>

<p>为了更好的安全性和可用性，<a href="https://12factor.net/config">建议</a>生成安全的随机密钥，并将其存储在运行应用程序的每个主机上的环境变量中，以便所有应用程序实例都将共享相同的密钥。并且应该定期更新会话密钥。下面是一些创建64比特密钥的例子:</p>

<h4 id="生成密钥">生成密钥</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">ruby</span> <span class="o">-</span><span class="n">e</span> <span class="s2">"require 'securerandom'; puts SecureRandom.hex(64)"</span>
<span class="mi">99</span><span class="n">ae8af</span><span class="o">...</span><span class="n">snip</span><span class="o">...</span><span class="n">ec0f262ac</span>
</code></pre></div></div>

<h4 id="生成密钥小贴士">生成密钥(小贴士)</h4>

<p>MRI Ruby目前认为<a href="https://github.com/cryptosphere/sysrandom">sysrandom gem</a>使用系统的随机数生成器要比用户态的<code class="highlighter-rouge">OpenSSL</code>好。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">sysrandom</span>
<span class="no">Building</span> <span class="n">native</span> <span class="n">extensions</span><span class="o">.</span>  <span class="no">This</span> <span class="n">could</span> <span class="n">take</span> <span class="n">a</span> <span class="k">while</span><span class="o">...</span>
<span class="no">Successfully</span> <span class="n">installed</span> <span class="n">sysrandom</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="nf">x</span>
<span class="mi">1</span> <span class="n">gem</span> <span class="n">installed</span>

<span class="err">$</span> <span class="n">ruby</span> <span class="o">-</span><span class="n">e</span> <span class="s2">"require 'sysrandom/securerandom'; puts SecureRandom.hex(64)"</span>
<span class="mi">99</span><span class="n">ae8af</span><span class="o">...</span><span class="n">snip</span><span class="o">...</span><span class="n">ec0f262ac</span>
</code></pre></div></div>

<h4 id="从环境变量使用密钥">从环境变量使用密钥</h4>

<p>将Sinatra的SESSION_SECRET环境变量设置为生成的值。在主机的重新启动之间保存这个值。由于这样做的方法会因系统而异，仅供说明之用：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># echo "export SESSION_SECRET=99ae8af...snip...ec0f262ac" &gt;&gt; ~/.bashrc
</code></pre></div></div>

<h4 id="应用的密钥配置">应用的密钥配置</h4>

<p>如果SESSION SECRET环境变量不可用，将把应用的随机密钥设置为不安全的。</p>

<p>关于<a href="https://github.com/cryptosphere/sysrandom">sysrandom gem</a>的更多用法:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'securerandom'</span>
<span class="c1"># -or- require 'sysrandom/securerandom'</span>
<span class="n">set</span> <span class="ss">:session_secret</span><span class="p">,</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s1">'SESSION_SECRET'</span><span class="p">)</span> <span class="p">{</span> <span class="no">SecureRandom</span><span class="p">.</span><span class="nf">hex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<h4 id="会话配置">会话配置</h4>

<p>如果你想进一步配置会话，可以在设置 <code class="highlighter-rouge">sessions</code> 时提供一个选项 hash 作为第二个参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:sessions</span><span class="p">,</span> <span class="ss">:domain</span> <span class="o">=&gt;</span> <span class="s1">'foo.com'</span>
</code></pre></div></div>

<p>为了在 foo.com 的子域名间共享会话数据，可以在域名前添加一个 <em>.</em>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:sessions</span><span class="p">,</span> <span class="ss">:domain</span> <span class="o">=&gt;</span> <span class="s1">'.foo.com'</span>
</code></pre></div></div>

<h4 id="选择你自己的会话中间件">选择你自己的会话中间件</h4>

<p>请注意 <code class="highlighter-rouge">enable :sessions</code> 实际将所有的数据保存在一个 cookie 中。
这可能并不总是你想要的（cookie 中存储大量的数据会增加你的流量）。
你可以使用任何 Rack session 中间件：要达到此目的，<strong>不要</strong>使用 <code class="highlighter-rouge">enable :sessions</code>，
而是按照自己的需要引入想使用的中间件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enable</span> <span class="ss">:sessions</span>
<span class="n">set</span> <span class="ss">:session_store</span><span class="p">,</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Session</span><span class="o">::</span><span class="no">Pool</span>
</code></pre></div></div>

<p>另一种选择是不要调用enable：sessions，而是像你想要的其他中间件一样加入你的中间件。</p>

<p>重要的是要注意，使用此方法时，默认情况下不会启用基于会话的保护。</p>

<p>还需要添加Rack中间件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Session</span><span class="o">::</span><span class="no">Pool</span><span class="p">,</span> <span class="ss">:expire_after</span> <span class="o">=&gt;</span> <span class="mi">2592000</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Protection</span><span class="o">::</span><span class="no">RemoteToken</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Protection</span><span class="o">::</span><span class="no">SessionHijacking</span>
</code></pre></div></div>
<p>更多<a href="https://github.com/sinatra/sinatra#configuring-attack-protection">安全防护配置</a>的信息。</p>

<h3 id="中断请求">中断请求</h3>

<p>要想在过滤器或路由中立即中断一个请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">halt</span>
</code></pre></div></div>

<p>你也可以指定中断时的状态码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">halt</span> <span class="mi">410</span>
</code></pre></div></div>

<p>或者响应主体：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">halt</span> <span class="s1">'this will be the body'</span>
</code></pre></div></div>

<p>或者同时指定两者：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">halt</span> <span class="mi">401</span><span class="p">,</span> <span class="s1">'go away!'</span>
</code></pre></div></div>

<p>也可以指定响应首部：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">halt</span> <span class="mi">402</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/plain'</span><span class="p">},</span> <span class="s1">'revenge'</span>
</code></pre></div></div>

<p>当然也可以使用模板：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>halt erb(:error)
</code></pre></div></div>

<h3 id="传递请求">传递请求</h3>

<p>一个路由可以放弃对请求的处理并将处理让给下一个匹配的路由，这要通过 <code class="highlighter-rouge">pass</code> 实现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/guess/:who'</span> <span class="k">do</span>
  <span class="n">pass</span> <span class="k">unless</span> <span class="n">params</span><span class="p">[</span><span class="s1">'who'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'Frank'</span>
  <span class="s1">'You got me!'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/guess/*'</span> <span class="k">do</span>
  <span class="s1">'You missed!'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>执行 <code class="highlighter-rouge">pass</code> 后，控制流从该路由代码块直接退出，并继续前进到下一个匹配的路由。
如果没有匹配的路由，将返回 404。</p>

<h3 id="触发另一个路由">触发另一个路由</h3>

<p>有些时候，<code class="highlighter-rouge">pass</code> 并不是你想要的，你希望得到的是调用另一个路由的结果。
使用 <code class="highlighter-rouge">call</code> 就可以做到这一点:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="n">call</span> <span class="n">env</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="s2">"PATH_INFO"</span> <span class="o">=&gt;</span> <span class="s1">'/bar'</span><span class="p">)</span>
  <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:upcase</span><span class="p">)]</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/bar'</span> <span class="k">do</span>
  <span class="s2">"bar"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>请注意在以上例子中，你只需简单地移动 <code class="highlighter-rouge">"bar"</code> 到一个被 <code class="highlighter-rouge">/foo</code> 和 <code class="highlighter-rouge">/bar</code> 同时使用的辅助方法中，
就可以简化测试和增加性能。</p>

<p>如果你希望请求发送到同一个应用，而不是应用副本，应使用 <code class="highlighter-rouge">call!</code> 而不是 <code class="highlighter-rouge">call</code>。</p>

<p>如果想更多了解关于 <code class="highlighter-rouge">call</code> 的信息，请查看 Rack 规范。</p>

<h3 id="设置响应主体状态码和响应首部">设置响应主体、状态码和响应首部</h3>

<p>推荐在路由代码块的返回值中设定状态码和响应主体。
但是，在某些场景下你可能想在别处设置响应主体，这时你可以使用 <code class="highlighter-rouge">body</code> 辅助方法。
设置之后，你可以在那以后使用该方法访问响应主体：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">body</span> <span class="s2">"bar"</span>
<span class="k">end</span>

<span class="n">after</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="n">body</span>
<span class="k">end</span>
</code></pre></div></div>

<p>也可以传递一个代码块给 <code class="highlighter-rouge">body</code> 方法，
它会被 Rack 处理器执行（这可以用来实现流式传输，参见“返回值”）。</p>

<p>与响应主体类似，你也可以设定状态码和响应首部：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">status</span> <span class="mi">418</span>
  <span class="n">headers</span> <span class="p">\</span>
    <span class="s2">"Allow"</span>   <span class="o">=&gt;</span> <span class="s2">"BREW, POST, GET, PROPFIND, WHEN"</span><span class="p">,</span>
    <span class="s2">"Refresh"</span> <span class="o">=&gt;</span> <span class="s2">"Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"</span>
  <span class="n">body</span> <span class="s2">"I'm a tea pot!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>正如 <code class="highlighter-rouge">body</code> 方法，不带参数调用 <code class="highlighter-rouge">headers</code> 和 <code class="highlighter-rouge">status</code> 方法可以访问它们的当前值。</p>

<h3 id="响应的流式传输">响应的流式传输</h3>

<p>有时你可能想在完全生成响应主体前返回数据。
更极端的情况是，你希望在客户端关闭连接前一直发送数据。
为满足这些需求，可以使用 <code class="highlighter-rouge">stream</code> 辅助方法而不必重新造轮子：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">stream</span> <span class="k">do</span> <span class="o">|</span><span class="n">out</span><span class="o">|</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s2">"It's gonna be legen -</span><span class="se">\n</span><span class="s2">"</span>
    <span class="nb">sleep</span> <span class="mf">0.5</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s2">" (wait for it) </span><span class="se">\n</span><span class="s2">"</span>
    <span class="nb">sleep</span> <span class="mi">1</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s2">"- dary!</span><span class="se">\n</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">stream</code> 辅助方法允许你实现流式 API 和
<a href="https://w3c.github.io/eventsource/">服务器端发送事件</a>，
同时它也是实现 <a href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a> 的基础。
如果你应用的部分（不是全部）内容依赖于访问缓慢的资源，它也可以用来提高并发能力。</p>

<p>请注意流式传输，尤其是并发请求数，高度依赖于应用所使用的服务器。
一些服务器可能根本不支持流式传输。
如果服务器不支持，传递给 <code class="highlighter-rouge">stream</code> 方法的代码块执行完毕之后，响应主体会一次性地发送给客户端。
Shotgun 完全不支持流式传输。</p>

<p>如果 <code class="highlighter-rouge">:keep_open</code> 作为可选参数传递给 <code class="highlighter-rouge">stream</code> 方法，将不会在流对象上调用 <code class="highlighter-rouge">close</code> 方法，
这允许你在控制流的下游某处手动关闭。该参数只对事件驱动的服务器（如 Thin 和 Rainbows）生效。
其它服务器仍会关闭流式传输：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 长轮询</span>

<span class="n">set</span> <span class="ss">:server</span><span class="p">,</span> <span class="ss">:thin</span>
<span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">get</span> <span class="s1">'/subscribe'</span> <span class="k">do</span>
  <span class="c1"># 在服务器端的事件中注册客户端</span>
  <span class="n">stream</span><span class="p">(</span><span class="ss">:keep_open</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">out</span><span class="o">|</span>
    <span class="n">connections</span> <span class="o">&lt;&lt;</span> <span class="n">out</span>
    <span class="c1"># 清除关闭的连接</span>
    <span class="n">connections</span><span class="p">.</span><span class="nf">reject!</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:closed?</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">post</span> <span class="s1">'/:message'</span> <span class="k">do</span>
  <span class="n">connections</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">out</span><span class="o">|</span>
    <span class="c1"># 通知客户端有条新消息</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">params</span><span class="p">[</span><span class="s1">'message'</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>

    <span class="c1"># 使客户端重新连接</span>
    <span class="n">out</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>

  <span class="c1"># 确认</span>
  <span class="s2">"message received"</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="日志">日志</h3>

<p>在请求作用域下，<code class="highlighter-rouge">logger</code> 辅助方法会返回一个 <code class="highlighter-rouge">Logger</code> 类的实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">logger</span><span class="p">.</span><span class="nf">info</span> <span class="s2">"loading data"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该 <code class="highlighter-rouge">logger</code> 方法会自动参考 Rack 处理器的日志设置。
若日志被禁用，该方法会返回一个无关痛痒的对象，所以你完全不必担心这会影响路由和过滤器。</p>

<p>注意只有 <code class="highlighter-rouge">Sinatra::Application</code> 默认开启了日志，若你的应用继承自 <code class="highlighter-rouge">Sinatra::Base</code>，
很可能需要手动开启：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">configure</span> <span class="ss">:production</span><span class="p">,</span> <span class="ss">:development</span> <span class="k">do</span>
    <span class="n">enable</span> <span class="ss">:logging</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>为避免使用任何与日志有关的中间件，需要将 <code class="highlighter-rouge">logging</code> 设置项设为 <code class="highlighter-rouge">nil</code>。
然而，在这种情况下，<code class="highlighter-rouge">logger</code> 辅助方法会返回 <code class="highlighter-rouge">nil</code>。
一种常见的使用场景是你想要使用自己的日志工具。
Sinatra 会使用 <code class="highlighter-rouge">env['rack.logger']</code> 的值作为日志工具，无论该值是什么。</p>

<h3 id="媒体类型">媒体类型</h3>

<p>使用 <code class="highlighter-rouge">send_file</code> 或者静态文件的时候，Sinatra 可能不会识别你的媒体类型。
使用 <code class="highlighter-rouge">mime_type</code> 通过文件扩展名来注册媒体类型：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mime_type</span> <span class="ss">:foo</span><span class="p">,</span> <span class="s1">'text/foo'</span>
</code></pre></div></div>

<p>你也可以使用 <code class="highlighter-rouge">content_type</code> 辅助方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">content_type</span> <span class="ss">:foo</span>
  <span class="s2">"foo foo foo"</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="生成-url">生成 URL</h3>

<p>为了生成 URL，你应当使用 <code class="highlighter-rouge">url</code> 辅助方法，例如，在 Haml 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">a</span><span class="p">{</span><span class="ss">:href</span> <span class="o">=&gt;</span> <span class="n">url</span><span class="p">(</span><span class="s1">'/foo'</span><span class="p">)}</span> <span class="n">foo</span>
</code></pre></div></div>

<p>如果使用了反向代理和 Rack 路由，生成 URL 的时候会考虑这些因素。</p>

<p>这个方法还有一个别名 <code class="highlighter-rouge">to</code> (见下面的例子)。</p>

<h3 id="浏览器重定向">浏览器重定向</h3>

<p>你可以通过 <code class="highlighter-rouge">redirect</code> 辅助方法触发浏览器重定向：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">redirect</span> <span class="n">to</span><span class="p">(</span><span class="s1">'/bar'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>其他参数的用法，与 <code class="highlighter-rouge">halt</code> 相同：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">redirect</span> <span class="n">to</span><span class="p">(</span><span class="s1">'/bar'</span><span class="p">),</span> <span class="mi">303</span>
<span class="n">redirect</span> <span class="s1">'http://www.google.com/'</span><span class="p">,</span> <span class="s1">'wrong place, buddy'</span>
</code></pre></div></div>

<p>用 <code class="highlighter-rouge">redirect back</code> 可以把用户重定向到原始页面：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="s2">"&lt;a href='/bar'&gt;do something&lt;/a&gt;"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/bar'</span> <span class="k">do</span>
  <span class="n">do_something</span>
  <span class="n">redirect</span> <span class="n">back</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果想传递参数给 redirect，可以用查询字符串：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">redirect</span> <span class="n">to</span><span class="p">(</span><span class="s1">'/bar?sum=42'</span><span class="p">)</span>
</code></pre></div></div>

<p>或者使用会话：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enable</span> <span class="ss">:sessions</span>

<span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">session</span><span class="p">[</span><span class="s1">'secret'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'foo'</span>
  <span class="n">redirect</span> <span class="n">to</span><span class="p">(</span><span class="s1">'/bar'</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/bar'</span> <span class="k">do</span>
  <span class="n">session</span><span class="p">[</span><span class="s1">'secret'</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="缓存控制">缓存控制</h3>

<p>正确设置响应首部是合理利用 HTTP 缓存的基础。</p>

<p>可以这样设定 Cache-Control 首部字段：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">cache_control</span> <span class="ss">:public</span>
  <span class="s2">"cache it!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>核心提示: 应当在 <code class="highlighter-rouge">before</code> 过滤器中设定缓存。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">before</span> <span class="k">do</span>
  <span class="n">cache_control</span> <span class="ss">:public</span><span class="p">,</span> <span class="ss">:must_revalidate</span><span class="p">,</span> <span class="ss">:max_age</span> <span class="o">=&gt;</span> <span class="mi">60</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果你使用 <code class="highlighter-rouge">expires</code> 辅助方法设定响应的响应首部， 会自动设定 <code class="highlighter-rouge">Cache-Control</code> 字段：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">before</span> <span class="k">do</span>
  <span class="n">expires</span> <span class="mi">500</span><span class="p">,</span> <span class="ss">:public</span><span class="p">,</span> <span class="ss">:must_revalidate</span>
<span class="k">end</span>
</code></pre></div></div>

<p>为了合理使用缓存，你应该考虑使用 <code class="highlighter-rouge">etag</code> 或 <code class="highlighter-rouge">last_modified</code> 方法。
推荐在执行繁重任务<em>之前</em>使用这些辅助方法，这样一来，
如果客户端在缓存中已经有相关内容，就会立即得到响应：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/article/:id'</span> <span class="k">do</span>
  <span class="vi">@article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">find</span> <span class="n">params</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span>
  <span class="n">last_modified</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">updated_at</span>
  <span class="n">etag</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">sha1</span>
  <span class="n">erb</span> <span class="ss">:article</span>
<span class="k">end</span>
</code></pre></div></div>

<p>也可以使用 <a href="https://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak ETag</a>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">etag</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">sha1</span><span class="p">,</span> <span class="ss">:weak</span>
</code></pre></div></div>

<p>这些辅助方法并不会为你做任何缓存，而是将必要的信息发送给你的缓存。
如果你正在寻找快捷的反向代理缓存方案，可以尝试
<a href="https://github.com/rtomayko/rack-cache">rack-cache</a>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"rack/cache"</span>
<span class="nb">require</span> <span class="s2">"sinatra"</span>

<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Cache</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">cache_control</span> <span class="ss">:public</span><span class="p">,</span> <span class="ss">:max_age</span> <span class="o">=&gt;</span> <span class="mi">36000</span>
  <span class="nb">sleep</span> <span class="mi">5</span>
  <span class="s2">"hello"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>使用 <code class="highlighter-rouge">:statis_cache_control</code> 设置（见下文）为静态文件添加 <code class="highlighter-rouge">Cache-Control</code> 首部字段。</p>

<p>根据 RFC 2616，如果 If-Match 或 If-None-Match 首部设置为 <code class="highlighter-rouge">*</code>，根据所请求的资源存在与否，
你的应用应当有不同的行为。
Sinatra 假设安全请求（如 GET）和幂等性请求（如 PUT）所访问的资源是已经存在的，
而其它请求（如 POST 请求）所访问的资源是新资源。
你可以通过传入 <code class="highlighter-rouge">:new_resource</code> 选项改变这一行为。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/create'</span> <span class="k">do</span>
  <span class="n">etag</span> <span class="s1">''</span><span class="p">,</span> <span class="ss">:new_resource</span> <span class="o">=&gt;</span> <span class="kp">true</span>
  <span class="no">Article</span><span class="p">.</span><span class="nf">create</span>
  <span class="n">erb</span> <span class="ss">:new_article</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果你仍想使用 weak ETag，可以传入一个 <code class="highlighter-rouge">:kind</code> 选项：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">etag</span> <span class="s1">''</span><span class="p">,</span> <span class="ss">:new_resource</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">:kind</span> <span class="o">=&gt;</span> <span class="ss">:weak</span>
</code></pre></div></div>

<h3 id="发送文件">发送文件</h3>

<p>为了将文件的内容作为响应返回，可以使用 <code class="highlighter-rouge">send_file</code> 辅助方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">send_file</span> <span class="s1">'foo.png'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该辅助方法接受一些选项:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">send_file</span> <span class="s1">'foo.png'</span><span class="p">,</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:jpg</span>
</code></pre></div></div>

<p>可用的选项有:</p>

<dl>
  <dt>filename</dt>
  <dd>响应中使用的文件名，默认是真实的文件名。</dd>

  <dt>last_modified</dt>
  <dd>Last-Modified 响应首部的值，默认是文件的 mtime （修改时间）。</dd>

  <dt>type</dt>
  <dd>Content-Type 响应首部的值，如果未指定，会根据文件扩展名猜测。</dd>

  <dt>disposition</dt>
  <dd>
    Content-Disposition 响应首部的值，
    可选的值有： <tt>nil</tt> (默认)、<tt>:attachment</tt> 和
    <tt>:inline</tt>
  </dd>

  <dt>length</dt>
  <dd>Content-Length 响应首部的值，默认是文件的大小。</dd>

  <dt>status</dt>
  <dd>
    将要返回的状态码。当以一个静态文件作为错误页面时，这很有用。

    如果 Rack 处理器支持的话，Ruby 进程也能使用除 streaming 以外的方法。
    如果你使用这个辅助方法， Sinatra会自动处理 range 请求。
  </dd>
</dl>

<h3 id="访问请求对象">访问请求对象</h3>

<p>传入的请求对象可以在请求层（过滤器、路由、错误处理器内部）通过 <code class="highlighter-rouge">request</code> 方法访问：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 在 http://example.com/example 上运行的应用</span>
<span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">t</span> <span class="o">=</span> <span class="sx">%w[text/css text/html application/javascript]</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">accept</span>              <span class="c1"># ['text/html', '*/*']</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">accept?</span> <span class="s1">'text/xml'</span>  <span class="c1"># true</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">preferred_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>   <span class="c1"># 'text/html'</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">body</span>                <span class="c1"># 客户端设定的请求主体（见下文）</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">scheme</span>              <span class="c1"># "http"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">script_name</span>         <span class="c1"># "/example"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">path_info</span>           <span class="c1"># "/foo"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">port</span>                <span class="c1"># 80</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">request_method</span>      <span class="c1"># "GET"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">query_string</span>        <span class="c1"># ""</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">content_length</span>      <span class="c1"># request.body 的长度</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">media_type</span>          <span class="c1"># request.body 的媒体类型</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">host</span>                <span class="c1"># "example.com"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">get?</span>                <span class="c1"># true (其它动词也具有类似方法)</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">form_data?</span>          <span class="c1"># false</span>
  <span class="n">request</span><span class="p">[</span><span class="s2">"some_param"</span><span class="p">]</span>       <span class="c1"># some_param 参数的值。[] 是访问 params hash 的捷径</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">referrer</span>            <span class="c1"># 客户端的 referrer 或者 '/'</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">user_agent</span>          <span class="c1"># 用户代理 (:agent 条件使用该值)</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">cookies</span>             <span class="c1"># 浏览器 cookies 哈希</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">xhr?</span>                <span class="c1"># 这是否是 ajax 请求？</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">url</span>                 <span class="c1"># "http://example.com/example/foo"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">path</span>                <span class="c1"># "/example/foo"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">ip</span>                  <span class="c1"># 客户端 IP 地址</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">secure?</span>             <span class="c1"># false （如果是 ssl 则为 true）</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">forwarded?</span>          <span class="c1"># true （如果是运行在反向代理之后）</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">env</span>                 <span class="c1"># Rack 中使用的未处理的 env hash</span>
<span class="k">end</span>
</code></pre></div></div>

<p>一些选项，例如 <code class="highlighter-rouge">script_name</code> 或者 <code class="highlighter-rouge">path_info</code> 也是可写的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">before</span> <span class="p">{</span> <span class="n">request</span><span class="p">.</span><span class="nf">path_info</span> <span class="o">=</span> <span class="s2">"/"</span> <span class="p">}</span>

<span class="n">get</span> <span class="s2">"/"</span> <span class="k">do</span>
  <span class="s2">"all requests end up here"</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">request.body</code> 是一个 IO 或者 StringIO 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">post</span> <span class="s2">"/api"</span> <span class="k">do</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">rewind</span>  <span class="c1"># 如果已经有人读了它</span>
  <span class="n">data</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span> <span class="n">request</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">read</span>
  <span class="s2">"Hello </span><span class="si">#{</span><span class="n">data</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="附件">附件</h3>

<p>你可以使用 <code class="highlighter-rouge">attachment</code> 辅助方法来告诉浏览器响应应当被写入磁盘而不是在浏览器中显示。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">attachment</span>
  <span class="s2">"store it!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>你也可以传递给该方法一个文件名：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">attachment</span> <span class="s2">"info.txt"</span>
  <span class="s2">"store it!"</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="处理日期和时间">处理日期和时间</h3>

<p>Sinatra 提供了一个 <code class="highlighter-rouge">time_for</code> 辅助方法，其目的是根据给定的值生成 Time 对象。
该方法也能够转换 <code class="highlighter-rouge">DateTime</code>、<code class="highlighter-rouge">Date</code> 和类似的类：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">pass</span> <span class="k">if</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">&gt;</span> <span class="n">time_for</span><span class="p">(</span><span class="s1">'Dec 23, 2012'</span><span class="p">)</span>
  <span class="s2">"still time"</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">expires</code>、<code class="highlighter-rouge">last_modified</code> 和类似方法都在内部使用了该方法。
因此，通过在应用中重写 <code class="highlighter-rouge">time_for</code> 方法，你可以轻松地扩展这些方法的行为：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">time_for</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">value</span>
    <span class="k">when</span> <span class="ss">:yesterday</span> <span class="k">then</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span>
    <span class="k">when</span> <span class="ss">:tomorrow</span> <span class="k">then</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">+</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span>
    <span class="k">else</span> <span class="k">super</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">last_modified</span> <span class="ss">:yesterday</span>
  <span class="n">expires</span> <span class="ss">:tomorrow</span>
  <span class="s2">"hello"</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="查找模板文件">查找模板文件</h3>

<p><code class="highlighter-rouge">find_template</code> 辅助方法用于在渲染时查找模板文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">find_template</span> <span class="n">settings</span><span class="p">.</span><span class="nf">views</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">,</span> <span class="no">Tilt</span><span class="p">[</span><span class="ss">:haml</span><span class="p">]</span> <span class="k">do</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s2">"could be </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这其实并不是很有用，除非你需要重载这个方法来实现你自己的查找机制。
比如，如果你想使用不只一个视图目录：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:views</span><span class="p">,</span> <span class="p">[</span><span class="s1">'views'</span><span class="p">,</span> <span class="s1">'templates'</span><span class="p">]</span>

<span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">find_template</span><span class="p">(</span><span class="n">views</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="no">Array</span><span class="p">(</span><span class="n">views</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="k">super</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>另一个例子是对不同的引擎使用不同的目录:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:views</span><span class="p">,</span> <span class="ss">:sass</span> <span class="o">=&gt;</span> <span class="s1">'views/sass'</span><span class="p">,</span> <span class="ss">:haml</span> <span class="o">=&gt;</span> <span class="s1">'templates'</span><span class="p">,</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="s1">'views'</span>

<span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">find_template</span><span class="p">(</span><span class="n">views</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">views</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="o">|</span> <span class="n">engine</span> <span class="o">==</span> <span class="no">Tilt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">}</span>
    <span class="n">folder</span> <span class="o">||=</span> <span class="n">views</span><span class="p">[</span><span class="ss">:default</span><span class="p">]</span>
    <span class="k">super</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>你可以很容易地封装成一个扩展，然后与他人分享！</p>

<p>请注意 <code class="highlighter-rouge">find_template</code> 并不会检查文件是否存在，而是为任何可能的路径调用传入的代码块。
这并不会导致性能问题，因为 <code class="highlighter-rouge">render</code> 会在找到文件的时候马上使用 <code class="highlighter-rouge">break</code>。
同样的，模板的路径（和内容）会在 development 以外的模式下被缓存。
你应该时刻提醒自己这一点， 如果你真的想写一个非常疯狂的方法的话。</p>

<h2 id="配置">配置</h2>

<p>在启动时运行一次，在任何环境下都是如此：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">configure</span> <span class="k">do</span>
  <span class="c1"># 设置一个选项</span>
  <span class="n">set</span> <span class="ss">:option</span><span class="p">,</span> <span class="s1">'value'</span>

  <span class="c1"># 设置多个选项</span>
  <span class="n">set</span> <span class="ss">:a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span> <span class="o">=&gt;</span> <span class="mi">2</span>

  <span class="c1"># 等同于 `set :option, true`</span>
  <span class="n">enable</span> <span class="ss">:option</span>

  <span class="c1"># 等同于 `set :option, false`</span>
  <span class="n">disable</span> <span class="ss">:option</span>

  <span class="c1"># 也可以用代码块做动态设置</span>
  <span class="n">set</span><span class="p">(</span><span class="ss">:css_dir</span><span class="p">)</span> <span class="p">{</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">views</span><span class="p">,</span> <span class="s1">'css'</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>只有当环境 (<code class="highlighter-rouge">APP_ENV</code> 环境变量) 被设定为 <code class="highlighter-rouge">:production</code> 时才运行：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">configure</span> <span class="ss">:production</span> <span class="k">do</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当环境被设定为 <code class="highlighter-rouge">:production</code> 或者 <code class="highlighter-rouge">:test</code> 时运行：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">configure</span> <span class="ss">:production</span><span class="p">,</span> <span class="ss">:test</span> <span class="k">do</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>你可以用 <code class="highlighter-rouge">settings</code> 访问这些配置项：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">configure</span> <span class="k">do</span>
  <span class="n">set</span> <span class="ss">:foo</span><span class="p">,</span> <span class="s1">'bar'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">settings</span><span class="p">.</span><span class="nf">foo?</span> <span class="c1"># =&gt; true</span>
  <span class="n">settings</span><span class="p">.</span><span class="nf">foo</span>  <span class="c1"># =&gt; 'bar'</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="配置攻击防护">配置攻击防护</h3>

<p>Sinatra 使用 <a href="https://github.com/sinatra/sinatra/tree/master/rack-protection#readme">Rack::Protection</a>
来抵御常见的攻击。你可以轻易地禁用该行为（但这会大大增加应用被攻击的概率）。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">disable</span> <span class="ss">:protection</span>
</code></pre></div></div>

<p>为了绕过某单层防护，可以设置 <code class="highlighter-rouge">protection</code> 为一个选项 hash：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:protection</span><span class="p">,</span> <span class="ss">:except</span> <span class="o">=&gt;</span> <span class="ss">:path_traversal</span>
</code></pre></div></div>

<p>你可以传入一个数组，以禁用一系列防护措施：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:protection</span><span class="p">,</span> <span class="ss">:except</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:path_traversal</span><span class="p">,</span> <span class="ss">:session_hijacking</span><span class="p">]</span>
</code></pre></div></div>

<p>默认地，如果 <code class="highlighter-rouge">:sessions</code> 是启用的，Sinatra 只会使用基于会话的防护措施。
当然，有时你可能想根据自己的需要设置会话。
在这种情况下，你可以通过传入 <code class="highlighter-rouge">:session</code> 选项来开启基于会话的防护。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Session</span><span class="o">::</span><span class="no">Pool</span>
<span class="n">set</span> <span class="ss">:protection</span><span class="p">,</span> <span class="ss">:session</span> <span class="o">=&gt;</span> <span class="kp">true</span>
</code></pre></div></div>

<h3 id="可选的设置">可选的设置</h3>

<dl>
  <dt>absolute_redirects</dt>
  <dd>
    如果被禁用，Sinatra 会允许使用相对路径重定向。
    然而这样的话，Sinatra 就不再遵守 RFC 2616 (HTTP 1.1), 该协议只允许绝对路径重定向。
  </dd>
  <dd>
    如果你的应用运行在一个未恰当设置的反向代理之后，你需要启用这个选项。
    注意 <tt>url</tt> 辅助方法仍然会生成绝对 URL，除非你传入<tt>false</tt> 作为第二参数。
  </dd>
  <dd>默认禁用。</dd>

  <dt>add_charset</dt>
  <dd>
    设置 <tt>content_type</tt> 辅助方法会自动为媒体类型加上字符集信息。
    你应该添加而不是覆盖这个选项:
    <tt>settings.add_charset &lt;&lt; "application/foobar"</tt>
  </dd>

  <dt>app_file</dt>
  <dd>
    主应用文件的路径，用来检测项目的根路径， views 和 public 文件夹和内联模板。
  </dd>

  <dt>bind</dt>
  <dd>
    绑定的 IP 地址 (默认: <tt>0.0.0.0</tt>，开发环境下为 <tt>localhost</tt>)。
    仅对于内置的服务器有用。
  </dd>

  <dt>default_encoding</dt>
  <dd>默认编码 (默认为 <tt>"utf-8"</tt>)。</dd>

  <dt>dump_errors</dt>
  <dd>在日志中显示错误。</dd>

  <dt>environment</dt>
  <dd>
    当前环境，默认是 <tt>ENV['APP_ENV']</tt>，
    或者 <tt>"development"</tt> (如果 ENV['APP_ENV'] 不可用)。
  </dd>

  <dt>logging</dt>
  <dd>使用 logger。</dd>

  <dt>lock</dt>
  <dd>对每一个请求放置一个锁，只使用进程并发处理请求。</dd>
  <dd>如果你的应用不是线程安全则需启动。默认禁用。</dd>

  <dt>method_override</dt>
  <dd>
    使用 <tt>_method</tt> 魔法，以允许在不支持的浏览器中在使用 put/delete 方法提交表单。
  </dd>

  <dt>port</dt>
  <dd>监听的端口号。只对内置服务器有用。</dd>

  <dt>prefixed_redirects</dt>
  <dd>
    如果没有使用绝对路径，是否添加 <tt>request.script_name</tt> 到重定向请求。
    如果添加，<tt>redirect '/foo'</tt> 会和 <tt>redirect to('/foo')</tt> 相同。
    默认禁用。
  </dd>

  <dt>protection</dt>
  <dd>是否启用网络攻击防护。参见上面的保护部分</dd>

  <dt>public_dir</dt>
  <dd>public_folder 的别名。见下文。</dd>

  <dt>public_folder</dt>
  <dd>
    public 文件存放的路径。只有启用了静态文件服务（见下文的 <tt>static</tt>）才会使用。
    如果未设置，默认从 <tt>app_file</tt> 推断。
  </dd>

  <dt>reload_templates</dt>
  <dd>
    是否每个请求都重新载入模板。在开发模式下开启。
  </dd>

  <dt>root</dt>
  <dd>到项目根目录的路径。默认从 <tt>app_file</tt> 设置推断。</dd>

  <dt>raise_errors</dt>
  <dd>
    抛出异常（会停止应用）。
    当 <tt>environment</tt> 设置为 <tt>"test"</tt> 时会默认开启，其它环境下默认禁用。
  </dd>

  <dt>run</dt>
  <dd>如果启用，Sinatra 会负责 web 服务器的启动。若使用 rackup 或其他方式则不要启用。</dd>

  <dt>running</dt>
  <dd>内置的服务器在运行吗？ 不要修改这个设置！</dd>

  <dt>server</dt>
  <dd>服务器，或用于内置服务器的服务器列表。顺序表明了优先级，默认顺序依赖 Ruby 实现。</dd>

  <dt>sessions</dt>
  <dd>
    使用 <tt>Rack::Session::Cookie</tt>，启用基于 cookie 的会话。
    查看“使用会话”部分以获得更多信息。
  </dd>

  <dt>show_exceptions</dt>
  <dd>
    当有异常发生时，在浏览器中显示一个 stack trace。
    当 <tt>environment</tt> 设置为 <tt>"development"</tt> 时，默认启用，
    否则默认禁用。
  </dd>
  <dd>
    也可以设置为 <tt>:after_handler</tt>，
    这会在浏览器中显示 stack trace 之前触发应用级别的错误处理。
  </dd>

  <dt>static</dt>
  <dd>决定 Sinatra 是否服务静态文件。</dd>
  <dd>当服务器能够自行服务静态文件时，会禁用。</dd>
  <dd>禁用会增强性能。</dd>
  <dd>在经典风格中默认启用，在模块化应用中默认禁用。</dd>

  <dt>static_cache_control</dt>
  <dd>
    当 Sinatra 提供静态文件服务时，设置此选项为响应添加 <tt>Cache-Control</tt> 首部。
    使用 <tt>cache_control</tt> 辅助方法。默认禁用。
  </dd>
  <dd>
    当设置多个值时使用数组：
    <tt>set :static_cache_control, [:public, :max_age =&gt; 300]</tt>
  </dd>

  <dt>threaded</dt>
  <dd>
    若设置为 <tt>true</tt>，会告诉 Thin 使用 <tt>EventMachine.defer</tt> 处理请求。
  </dd>

  <dt>traps</dt>
  <dd>Sinatra 是否应该处理系统信号。</dd>

  <dt>views</dt>
  <dd>views 文件夹的路径。若未设置则会根据 <tt>app_file</tt> 推断。</dd>

  <dt>x_cascade</dt>
  <dd>若没有路由匹配，是否设置 X-Cascade 首部。默认为 <tt>true</tt>。</dd>
</dl>

<h2 id="环境">环境</h2>

<p>Sinatra 中有三种预先定义的环境：”development”、”production” 和 “test”。
环境可以通过 <code class="highlighter-rouge">APP_ENV</code> 环境变量设置。默认值为 “development”。
在开发环境下，每次请求都会重新加载所有模板，
特殊的 <code class="highlighter-rouge">not_found</code> 和 <code class="highlighter-rouge">error</code> 错误处理器会在浏览器中显示 stack trace。
在测试和生产环境下，模板默认会缓存。</p>

<p>在不同的环境下运行，设置 <code class="highlighter-rouge">APP_ENV</code> 环境变量：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">APP_ENV</span><span class="o">=</span>production ruby my_app.rb
</code></pre></div></div>

<p>可以使用预定义的三种方法： <code class="highlighter-rouge">development?</code>、<code class="highlighter-rouge">test?</code> 和 <code class="highlighter-rouge">production?</code> 来检查当前环境：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">settings</span><span class="p">.</span><span class="nf">development?</span>
    <span class="s2">"development!"</span>
  <span class="k">else</span>
    <span class="s2">"not development"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="错误处理">错误处理</h2>

<p>错误处理器在与路由和 before 过滤器相同的上下文中运行，
这意味着你可以使用许多好东西，比如 <code class="highlighter-rouge">haml</code>, <code class="highlighter-rouge">erb</code>, <code class="highlighter-rouge">halt</code>，等等。</p>

<h3 id="未找到">未找到</h3>

<p>当一个 <code class="highlighter-rouge">Sinatra::NotFound</code> 错误被抛出时，或者当响应的状态码是 404 时，
会调用 <code class="highlighter-rouge">not_found</code> 处理器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">not_found</span> <span class="k">do</span>
  <span class="s1">'This is nowhere to be found.'</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="错误">错误</h3>

<p>在任何路由代码块或过滤器抛出异常时，会调用 <code class="highlighter-rouge">error</code> 处理器。
但注意在开发环境下只有将 show exceptions 项设置为 <code class="highlighter-rouge">:after_handler</code> 时，才会生效。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span> <span class="ss">:show_exceptions</span><span class="p">,</span> <span class="ss">:after_handler</span>
</code></pre></div></div>

<p>可以用 Rack 变量 <code class="highlighter-rouge">sinatra.error</code> 访问异常对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span> <span class="k">do</span>
  <span class="s1">'Sorry there was a nasty error - '</span> <span class="o">+</span> <span class="n">env</span><span class="p">[</span><span class="s1">'sinatra.error'</span><span class="p">].</span><span class="nf">message</span>
<span class="k">end</span>
</code></pre></div></div>

<p>自定义错误：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span> <span class="no">MyCustomError</span> <span class="k">do</span>
  <span class="s1">'So what happened was...'</span> <span class="o">+</span> <span class="n">env</span><span class="p">[</span><span class="s1">'sinatra.error'</span><span class="p">].</span><span class="nf">message</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当下面的代码执行时：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="k">raise</span> <span class="no">MyCustomError</span><span class="p">,</span> <span class="s1">'something bad'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>你会得到错误信息：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>So what happened was... something bad
</code></pre></div></div>

<p>或者，你也可以为状态码设置错误处理器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span> <span class="mi">403</span> <span class="k">do</span>
  <span class="s1">'Access forbidden'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/secret'</span> <span class="k">do</span>
  <span class="mi">403</span>
<span class="k">end</span>
</code></pre></div></div>

<p>或者为某个范围内的状态码统一设置错误处理器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span> <span class="mi">400</span><span class="o">..</span><span class="mi">510</span> <span class="k">do</span>
  <span class="s1">'Boom'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在开发环境下，Sinatra会使用特殊的 <code class="highlighter-rouge">not_found</code> 和 <code class="highlighter-rouge">error</code> 处理器，
以便在浏览器中显示美观的 stack traces 和额外的调试信息。</p>

<h2 id="rack-中间件">Rack 中间件</h2>

<p>Sinatra 依赖 <a href="http://rack.github.io/">Rack</a>, 一个面向 Ruby 网络框架的最小化标准接口。
Rack 最有趣的功能之一是支持“中间件”——位于服务器和你的应用之间的组件，
它们监控或操作 HTTP 请求/响应以提供多种常用功能。</p>

<p>Sinatra 通过顶层的 <code class="highlighter-rouge">use</code> 方法，让建立 Rack 中间件管道异常简单：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>
<span class="nb">require</span> <span class="s1">'my_custom_middleware'</span>

<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Lint</span>
<span class="n">use</span> <span class="no">MyCustomMiddleware</span>

<span class="n">get</span> <span class="s1">'/hello'</span> <span class="k">do</span>
  <span class="s1">'Hello World'</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">use</code> 的语义和在  <a href="http://www.rubydoc.info/github/rack/rack/master/Rack/Builder">Rack::Builder</a>
DSL (在 rackup 文件中最频繁使用)中定义的完全一样。例如，<code class="highlighter-rouge">use</code> 方法接受
多个/可变参数，以及代码块：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Auth</span><span class="o">::</span><span class="no">Basic</span> <span class="k">do</span> <span class="o">|</span><span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="o">|</span>
  <span class="n">username</span> <span class="o">==</span> <span class="s1">'admin'</span> <span class="o">&amp;&amp;</span> <span class="n">password</span> <span class="o">==</span> <span class="s1">'secret'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Rack 拥有有多种标准中间件，用于日志、调试、URL 路由、认证和会话处理。
根据配置，Sinatra 可以自动使用这里面的许多组件，
所以你一般不需要显式地 <code class="highlighter-rouge">use</code> 它们。</p>

<p>你可以在 <a href="https://github.com/rack/rack/tree/master/lib/rack">rack</a>、
<a href="https://github.com/rack/rack-contrib#readm">rack-contrib</a> 或
<a href="https://github.com/rack/rack/wiki/List-of-Middleware">Rack wiki</a>
中找到有用的中间件。</p>

<h2 id="测试">测试</h2>

<p>可以使用任何基于 Rack 的测试程序库或者框架来编写Sinatra的测试。
推荐使用 <a href="http://www.rubydoc.info/github/brynary/rack-test/master/frames">Rack::Test</a>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'my_sinatra_app'</span>
<span class="nb">require</span> <span class="s1">'minitest/autorun'</span>
<span class="nb">require</span> <span class="s1">'rack/test'</span>

<span class="k">class</span> <span class="nc">MyAppTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="kp">include</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Test</span><span class="o">::</span><span class="no">Methods</span>

  <span class="k">def</span> <span class="nf">app</span>
    <span class="no">Sinatra</span><span class="o">::</span><span class="no">Application</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_my_default</span>
    <span class="n">get</span> <span class="s1">'/'</span>
    <span class="n">assert_equal</span> <span class="s1">'Hello World!'</span><span class="p">,</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">body</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_with_params</span>
    <span class="n">get</span> <span class="s1">'/meet'</span><span class="p">,</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s1">'Frank'</span>
    <span class="n">assert_equal</span> <span class="s1">'Hello Frank!'</span><span class="p">,</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">body</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_with_rack_env</span>
    <span class="n">get</span> <span class="s1">'/'</span><span class="p">,</span> <span class="p">{},</span> <span class="s1">'HTTP_USER_AGENT'</span> <span class="o">=&gt;</span> <span class="s1">'Songbird'</span>
    <span class="n">assert_equal</span> <span class="s2">"You're using Songbird!"</span><span class="p">,</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">body</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>注意：如果你使用 Sinatra 的模块化风格，应该用你应用的类名替代 <code class="highlighter-rouge">Sinatra::Application</code>。</p>

<h2 id="sinatrabase---中间件库和模块化应用">Sinatra::Base - 中间件、库和模块化应用</h2>

<p>在顶层定义你的应用很适合微型项目，
但是在构建可复用的组件（如 Rack 中间件、Rails metal、带服务器组件的库或 Sinatra 扩展）时，
却有相当大的缺陷。
顶层 DSL 认为你采用的是微型应用风格的配置 (例如：唯一应用文件、
<code class="highlighter-rouge">./public</code> 和 <code class="highlighter-rouge">./views</code> 目录、日志、异常细节页面等）。
如果你的项目不采用微型应用风格，应该使用 <code class="highlighter-rouge">Sinatra::Base</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">set</span> <span class="ss">:sessions</span><span class="p">,</span> <span class="kp">true</span>
  <span class="n">set</span> <span class="ss">:foo</span><span class="p">,</span> <span class="s1">'bar'</span>

  <span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
    <span class="s1">'Hello world!'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Sinatra::Base 的子类可以使用的方法实际上就是顶层 DSL 中可以使用的方法。
大部分顶层应用可以通过两方面的改变转换为 Sinatra::Base 组件：</p>

<ul>
  <li>
    <p>你的文件应当引入 <code class="highlighter-rouge">sinatra/base</code> 而不是 <code class="highlighter-rouge">sinatra</code>；
否则，Sinatra 的所有 DSL 方法将会被导入主命名空间。</p>
  </li>
  <li>
    <p>把应用的路由、错误处理器、过滤器和选项放在一个 Sinatra::Base 的子类中。</p>
  </li>
</ul>

<p><code class="highlighter-rouge">Sinatra::Base</code> 是一个白板。大部分选项（包括内置的服务器）默认是禁用的。
可以参考<a href="http://www.sinatrarb.com/configuration.html">配置</a>
以查看可用选项的具体细节和它们的行为。如果你想让你的应用更像顶层定义的应用（即经典风格），
你可以继承 <code class="highlighter-rouge">Sinatra::Applicaiton</code>。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Application</span>
  <span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
    <span class="s1">'Hello world!'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="模块化风格-vs-经典风格">模块化风格 vs. 经典风格</h3>

<p>与通常的认识相反，经典风格并没有任何错误。
如果它适合你的应用，你不需要切换到模块化风格。</p>

<p>与模块化风格相比，经典风格的主要缺点在于，每个 Ruby 进程只能有一个 Sinatra 应用。
如果你计划使用多个 Sinatra 应用，应该切换到模块化风格。
你也完全可以混用模块化风格和经典风格。</p>

<p>如果从一种风格转换到另一种，你需要注意默认设置中的一些细微差别：</p>

<table>
  <tr>
    <th>设置</th>
    <th>经典风格</th>
    <th>模块化风格</th>
    <th>模块化风格</th>
  </tr>

  <tr>
    <td>app_file</td>
    <td>加载 sinatra 的文件</td>
    <td>继承 Sinatra::Base 的文件</td>
    <td>继承 Sinatra::Application 的文件</td>
  </tr>

  <tr>
    <td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
    <td>false</td>
  </tr>

  <tr>
    <td>logging</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>method_override</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>inline_templates</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>static</td>
    <td>true</td>
    <td>File.exist?(public_folder)</td>
    <td>true</td>
  </tr>
</table>

<h3 id="运行一个模块化应用">运行一个模块化应用</h3>

<p>模块化应用的启动有两种常见方式，其中之一是使用 <code class="highlighter-rouge">run!</code> 方法主动启动:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># my_app.rb</span>
<span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ... 这里是应用代码 ...</span>

  <span class="c1"># 如果直接执行该文件，那么启动服务器</span>
  <span class="n">run!</span> <span class="k">if</span> <span class="n">app_file</span> <span class="o">==</span> <span class="vg">$0</span>
<span class="k">end</span>
</code></pre></div></div>

<p>执行该文件就会启动服务器：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby my_app.rb
</code></pre></div></div>

<p>另一种方式是使用 <code class="highlighter-rouge">config.ru</code> 文件，这种方式允许你使用任何 Rack 处理器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.ru （用 rackup 启动）</span>
<span class="nb">require</span> <span class="s1">'./my_app'</span>
<span class="n">run</span> <span class="no">MyApp</span>
</code></pre></div></div>

<p>运行：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rackup <span class="nt">-p</span> 4567
</code></pre></div></div>

<h3 id="使用-configru-运行经典风格的应用">使用 config.ru 运行经典风格的应用</h3>

<p>编写你的应用:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app.rb</span>
<span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="s1">'Hello world!'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>添加相应的 <code class="highlighter-rouge">config.ru</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'./app'</span>
<span class="n">run</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Application</span>
</code></pre></div></div>

<h3 id="何时使用-configru">何时使用 config.ru？</h3>

<p>下列情况，推荐使用 <code class="highlighter-rouge">config.ru</code>：</p>

<ul>
  <li>部署时使用不同的 Rack 处理器 (Passenger、Unicorn、Heroku 等)。</li>
  <li>使用多个 <code class="highlighter-rouge">Sinatra::Base</code> 的子类。</li>
  <li>把 Sinatra 当作中间件使用，而非端点。</li>
</ul>

<p><strong>你不必仅仅因为想使用模块化风格而切换到 <code class="highlighter-rouge">config.ru</code>，同样的，
你也不必仅仅因为要运行 <code class="highlighter-rouge">config.ru</code> 而切换到模块化风格。</strong></p>

<h3 id="把-sinatra-当作中间件使用">把 Sinatra 当作中间件使用</h3>

<p>Sinatra 可以使用其它 Rack 中间件，
反过来，任何 Sinatra 应用程序自身都可以被当作中间件，添加到任何 Rack 端点前面。
此端点可以是任何 Sinatra 应用，或任何基于 Rack 的应用程序 (Rails/Ramaze/Camping/…)：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">LoginScreen</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">enable</span> <span class="ss">:sessions</span>

  <span class="n">get</span><span class="p">(</span><span class="s1">'/login'</span><span class="p">)</span> <span class="p">{</span> <span class="n">haml</span> <span class="ss">:login</span> <span class="p">}</span>

  <span class="n">post</span><span class="p">(</span><span class="s1">'/login'</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'admin'</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">[</span><span class="s1">'password'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'admin'</span>
      <span class="n">session</span><span class="p">[</span><span class="s1">'user_name'</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="n">redirect</span> <span class="s1">'/login'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># 中间件的执行发生在 before 过滤器之前</span>
  <span class="n">use</span> <span class="no">LoginScreen</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="k">unless</span> <span class="n">session</span><span class="p">[</span><span class="s1">'user_name'</span><span class="p">]</span>
      <span class="n">halt</span> <span class="s2">"Access denied, please &lt;a href='/login'&gt;login&lt;/a&gt;."</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"Hello </span><span class="si">#{</span><span class="n">session</span><span class="p">[</span><span class="s1">'user_name'</span><span class="p">]</span><span class="si">}</span><span class="s2">."</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="创建动态应用">创建动态应用</h3>

<p>有时你希望在运行时创建新应用，而不必把应用预先赋值给常量。这时可以使用 <code class="highlighter-rouge">Sinatra.new</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>
<span class="n">my_app</span> <span class="o">=</span> <span class="no">Sinatra</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"hi"</span> <span class="p">}</span> <span class="p">}</span>
<span class="n">my_app</span><span class="p">.</span><span class="nf">run!</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Sinatra.new</code> 接受一个可选的参数，表示要继承的应用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.ru (用 rackup 启动)</span>
<span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="n">controller</span> <span class="o">=</span> <span class="no">Sinatra</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">enable</span> <span class="ss">:logging</span>
  <span class="n">helpers</span> <span class="no">MyHelpers</span>
<span class="k">end</span>

<span class="n">map</span><span class="p">(</span><span class="s1">'/a'</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">run</span> <span class="no">Sinatra</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span> <span class="p">{</span> <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'a'</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">map</span><span class="p">(</span><span class="s1">'/b'</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">run</span> <span class="no">Sinatra</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span> <span class="p">{</span> <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'b'</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当你测试 Sinatra 扩展或在自己的类库中使用 Sinatra 时，这非常有用。</p>

<p>这也让把 Sinatra 当作中间件使用变得极其容易：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="n">use</span> <span class="no">Sinatra</span> <span class="k">do</span>
  <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">run</span> <span class="no">RailsProject</span><span class="o">::</span><span class="no">Application</span>
</code></pre></div></div>

<h2 id="作用域和绑定">作用域和绑定</h2>

<p>当前作用域决定了可以使用的方法和变量。</p>

<h3 id="应用类作用域">应用/类作用域</h3>

<p>每个 Sinatra 应用都对应 <code class="highlighter-rouge">Sinatra::Base</code> 类的一个子类。
如果你在使用顶层 DSL (<code class="highlighter-rouge">require 'sinatra'</code>)，那么这个类就是 <code class="highlighter-rouge">Sinatra::Application</code>，
否则该类是你显式创建的子类。
在类层面，你可以使用 <code class="highlighter-rouge">get</code> 或 <code class="highlighter-rouge">before</code> 这样的方法，
但不能访问 <code class="highlighter-rouge">request</code> 或 <code class="highlighter-rouge">session</code> 对象, 因为对于所有的请求，只有单一的应用类。</p>

<p>通过 <code class="highlighter-rouge">set</code> 创建的选项是类方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># 嘿，我在应用作用域！</span>
  <span class="n">set</span> <span class="ss">:foo</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">foo</span> <span class="c1"># =&gt; 42</span>

  <span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
    <span class="c1"># 嘿，我已经不在应用作用域了！</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>下列位置绑定的是应用作用域：</p>

<ul>
  <li>应用类内部</li>
  <li>通过扩展定义的方法内部</li>
  <li>传递给 <code class="highlighter-rouge">helpers</code> 方法的代码块内部</li>
  <li>作为 <code class="highlighter-rouge">set</code> 值的 procs/blocks 内部</li>
  <li>传递给 <code class="highlighter-rouge">Sinatra.new</code> 的代码块内部</li>
</ul>

<p>你可以这样访问变量域对象（应用类）：</p>
<ul>
  <li>通过传递给 configure 代码块的对象 (<code class="highlighter-rouge">configure { |c| ... }</code>)</li>
  <li>在请求作用域中使用 <code class="highlighter-rouge">settings</code></li>
</ul>

<h3 id="请求实例作用域">请求/实例作用域</h3>

<p>对于每个请求，Sinatra 会创建应用类的一个新实例。所有的处理器代码块都在该实例对象的作用域中运行。
在该作用域中， 你可以访问 <code class="highlighter-rouge">request</code> 和 <code class="highlighter-rouge">session</code> 对象，
或调用渲染方法（如 <code class="highlighter-rouge">erb</code>、<code class="highlighter-rouge">haml</code>）。你可以在请求作用域中通过 <code class="highlighter-rouge">settings</code> 辅助方法
访问应用作用域：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># 嘿，我在应用作用域!</span>
  <span class="n">get</span> <span class="s1">'/define_route/:name'</span> <span class="k">do</span>
    <span class="c1"># '/define_route/:name' 的请求作用域</span>
    <span class="vi">@value</span> <span class="o">=</span> <span class="mi">42</span>

    <span class="n">settings</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"/</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="k">do</span>
      <span class="c1"># "/#{params['name']}" 的请求作用域</span>
      <span class="vi">@value</span> <span class="c1"># =&gt; nil (并不是同一个请求)</span>
    <span class="k">end</span>

    <span class="s2">"Route defined!"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>以下位置绑定的是请求作用域：</p>

<ul>
  <li>get、head、post、put、delete、options、patch、link 和 unlink 代码块内部</li>
  <li>before 和 after 过滤器内部</li>
  <li>辅助方法内部</li>
  <li>模板/视图内部</li>
</ul>

<h3 id="代理作用域">代理作用域</h3>

<p>代理作用域只是把方法转送到类作用域。
然而，它与类作用域的行为并不完全相同, 因为你并不能在代理作用域获得类的绑定。
只有显式地标记为供代理使用的方法才是可用的，
而且你不能和类作用域共享变量/状态。(解释：你有了一个不同的 <code class="highlighter-rouge">self</code>)。
你可以通过调用 <code class="highlighter-rouge">Sinatra::Delegator.delegate :method_name</code> 显式地添加方法代理。</p>

<p>以下位置绑定的是代理变量域：</p>
<ul>
  <li>顶层绑定，如果你执行了 <code class="highlighter-rouge">require "sinatra"</code></li>
  <li>扩展了 <code class="highlighter-rouge">Sinatra::Delegator</code> 这一 mixin 的对象内部</li>
</ul>

<p>自己在这里看一下源码：<a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633">Sinatra::Delegator
mixin</a>
已经
<a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30">被扩展进了 main 对象</a>。</p>

<h2 id="命令行">命令行</h2>

<p>可以直接运行 Sinatra 应用：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby myapp.rb <span class="o">[</span><span class="nt">-h</span><span class="o">]</span> <span class="o">[</span><span class="nt">-x</span><span class="o">]</span> <span class="o">[</span><span class="nt">-e</span> ENVIRONMENT] <span class="o">[</span><span class="nt">-p</span> PORT] <span class="o">[</span><span class="nt">-o</span> HOST] <span class="o">[</span><span class="nt">-s</span> HANDLER]
</code></pre></div></div>

<p>选项是：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-h # 显示帮助
-p # 设置端口号 (默认是 4567)
-o # 设定主机名 (默认是 0.0.0.0)
-e # 设置环境 (默认是 development)
-s # 声明 rack 服务器/处理器 (默认是 thin)
-x # 打开互斥锁 (默认是 off)
</code></pre></div></div>

<h3 id="多线程">多线程</h3>

<p><em>根据 Konstantin 的 <a href="http://stackoverflow.com/questions/6278817/is-sinatra-multi-threaded/6282999#6282999)">这个 StackOverflow 答案</a> 改写</em></p>

<p>Sinatra 本身并不使用任何并发模型，而是将并发的任务留给底层的
Rack 处理器（服务器），如 Thin、Puma 或 WEBrick。Sinatra 本身是线程安全的，所以
Rack 处理器使用多线程并发模型并无任何问题。这意味着在启动服务器时，你必须指定特定
Rack 处理器的正确调用方法。
下面的例子展示了如何启动一个多线程的 Thin 服务器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app.rb</span>

<span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">App</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
    <span class="s2">"Hello, World"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">App</span><span class="p">.</span><span class="nf">run!</span>

</code></pre></div></div>

<p>启动服务器的命令是：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thin <span class="nt">--threaded</span> start
</code></pre></div></div>

<h2 id="必要条件">必要条件</h2>

<p>以下 Ruby 版本受官方支持:</p>
<dl>
  <dt>Ruby 1.8.7</dt>
  <dd>
    Sinatra 完全支持 1.8.7，但是，除非必要，我们推荐你升级或者切换到
    JRuby 或 Rubinius。Sinatra 2.0 之前都不会取消对 1.8.7
    的支持。Ruby 1.8.6 目前已不受支持。
  </dd>

  <dt>Ruby 1.9.2</dt>
  <dd>
    Sinatra 完全支持 1.9.2。
    不要使用 1.9.2p0，它在运行 Sinatra 程序时会产生 segmentation faults 错误。
    至少在 Sinatra 1.5 发布之前，官方对 1.9.2 的支持仍会继续。
  </dd>

  <dt>Ruby 1.9.3</dt>
  <dd>
    Sinatra 完全支持并推荐使用 1.9.3。请注意从更早的版本迁移到 1.9.3 会使所有的会话失效。
    直到 Sinatra 2.0 发布之前，官方仍然会支持 1.9.3。
  </dd>

  <dt>Ruby 2.x</dt>
  <dd>
    Sinatra 完全支持并推荐使用 2.x。目前尚无停止支持 2.x 的计划。
  </dd>

  <dt>Rubinius</dt>
  <dd>
    Sinatra 官方支持 Rubinius (Rubinius &gt;= 2.x)。推荐 <tt>gem install puma</tt>。
  </dd>

  <dt>JRuby</dt>
  <dd>
    Sinatra 官方支持 JRuby 的最新稳定版本，但不推荐在 JRuby 上使用 C 扩展。
    推荐 <tt>gem install trinidad</tt>。
  </dd>
</dl>

<p>我们也在时刻关注新的 Ruby 版本。</p>

<p>以下 Ruby 实现不受 Sinatra 官方支持，但可以运行 Sinatra：</p>

<ul>
  <li>老版本 JRuby 和 Rubinius</li>
  <li>Ruby 企业版</li>
  <li>MacRuby、Maglev、IronRuby</li>
  <li>Ruby 1.9.0 和 1.9.1 （不推荐使用）</li>
</ul>

<p>不受官方支持的意思是，如果仅在不受支持的 Ruby 实现上发生错误，我们认为不是我们的问题，而是该实现的问题。</p>

<p>我们同时也针对 ruby-head （MRI 的未来版本）运行 CI，但由于 ruby-head 一直处在变化之中，
我们不能作任何保证。我们期望完全支持未来的 2.x 版本。</p>

<p>Sinatra 应该会运行在任何支持上述 Ruby 实现的操作系统上。</p>

<p>如果你使用 MacRuby，你应该 <code class="highlighter-rouge">gem install control_tower</code>。</p>

<p>Sinatra 目前不支持 Cardinal、SmallRuby、BlueRuby 或其它 1.8.7 之前的 Ruby 版本。</p>

<h2 id="紧跟前沿">紧跟前沿</h2>

<p>如果你想使用 Sinatra 的最新代码，请放心使用 master 分支来运行你的程序，它是相当稳定的。</p>

<p>我们也会不定期推出 prerelease gems，所以你也可以运行</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem <span class="nb">install </span>sinatra <span class="nt">--pre</span>
</code></pre></div></div>

<p>来获得最新的特性。</p>

<h3 id="通过-bundler-使用-sinatra">通过 Bundler 使用 Sinatra</h3>

<p>如果你想在应用中使用最新的 Sinatra，推荐使用 <a href="http://bundler.io">Bundler</a>。</p>

<p>首先，安装 Bundler，如果你还没有安装的话：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem <span class="nb">install </span>bundler
</code></pre></div></div>

<p>然后，在你的项目目录下创建一个 <code class="highlighter-rouge">Gemfile</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">source</span> <span class="s1">'https://rubygems.org'</span>
<span class="n">gem</span> <span class="s1">'sinatra'</span><span class="p">,</span> <span class="ss">:github</span> <span class="o">=&gt;</span> <span class="s2">"sinatra/sinatra"</span>

<span class="c1"># 其它依赖</span>
<span class="n">gem</span> <span class="s1">'haml'</span>                    <span class="c1"># 假如你使用 haml</span>
<span class="n">gem</span> <span class="s1">'activerecord'</span><span class="p">,</span> <span class="s1">'~&gt; 3.0'</span>  <span class="c1"># 也许你还需要 ActiveRecord 3.x</span>
</code></pre></div></div>

<p>请注意你必须在 <code class="highlighter-rouge">Gemfile</code> 中列出应用的所有依赖项。
然而， Sinatra 的直接依赖项 (Rack 和 Tilt) 则会被 Bundler 自动获取和添加。</p>

<p>现在你可以这样运行你的应用:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle <span class="nb">exec </span>ruby myapp.rb
</code></pre></div></div>

<h3 id="使用自己本地的-sinatra">使用自己本地的 Sinatra</h3>

<p>创建一个本地克隆，并通过 <code class="highlighter-rouge">$LOAD_PATH</code> 里的 <code class="highlighter-rouge">sinatra/lib</code> 目录运行你的应用：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>myapp
git clone git://github.com/sinatra/sinatra.git
ruby <span class="nt">-I</span> sinatra/lib myapp.rb
</code></pre></div></div>

<p>为了在未来更新 Sinatra 源代码：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>myapp/sinatra
git pull
</code></pre></div></div>

<h3 id="全局安装">全局安装</h3>

<p>你可以自行编译 Sinatra gem：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git://github.com/sinatra/sinatra.git
<span class="nb">cd </span>sinatra
rake sinatra.gemspec
rake <span class="nb">install</span>
</code></pre></div></div>

<p>如果你以 root 身份安装 gems，最后一步应该是：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>rake <span class="nb">install</span>
</code></pre></div></div>

<h2 id="版本">版本</h2>

<p>Sinatra 遵循<a href="http://semver.org">语义化版本</a>，无论是 SemVer 还是 SemVerTag。</p>

<h2 id="更多资料">更多资料</h2>

<ul>
  <li><a href="http://www.sinatrarb.com/">项目官网</a> - 更多文档、新闻和其它资源的链接。</li>
  <li><a href="http://www.sinatrarb.com/contributing">贡献</a> - 找到一个 bug？需要帮助？有了一个 patch？</li>
  <li><a href="https://github.com/sinatra/sinatra/issues">问题追踪</a></li>
  <li><a href="https://twitter.com/sinatra">Twitter</a></li>
  <li><a href="http://groups.google.com/group/sinatrarb/topics">邮件列表</a></li>
  <li>IRC: <a href="irc://chat.freenode.net/#sinatra">#sinatra</a> on http://freenode.net</li>
  <li><a href="https://sinatrarb.slack.com">Sinatra &amp; Friends</a> on Slack，点击
<a href="https://sinatra-slack.herokuapp.com/">这里</a> 获得邀请。</li>
  <li><a href="https://github.com/sinatra/sinatra-book/">Sinatra Book</a> Cookbook 教程</li>
  <li><a href="http://recipes.sinatrarb.com/">Sinatra Recipes</a> 社区贡献的实用技巧</li>
  <li>http://www.rubydoc.info/ 上<a href="http://www.rubydoc.info//gems/sinatra">最新版本</a>或<a href="http://www.rubydoc.info/github/sinatra/sinatra">当前 HEAD</a> 的 API 文档</li>
  <li><a href="https://travis-ci.org/sinatra/sinatra">CI 服务器</a></li>
</ul>
:ET